#!/usr/bin/env php
<?php

declare(strict_types=1);

use Relay\Table;
use Monolog\Formatter\LineFormatter;
use Monolog\Handler\StreamHandler;
use Monolog\LogRecord;
use Monolog\Logger;
use Psr\Log\InvalidArgumentException;

require_once __DIR__ . '/vendor/autoload.php';

function usage(): void
{
    $msg = <<<TXT
Relay Table fuzzer

Usage:
  ./fuzzer --ops N [--workers N] [--seed INT] [--keys N]
           [--include csl] [--exclude csl]
           [--mode random|queue] [--redis host:port] [--list name]
           [--log-level level] [--status-interval SECONDS]

Notes:
  - If --seed is omitted, hrtime(true) is used.
  - If --workers=0, no fork is performed.
  - --mode=queue uses Redis; parent enqueues commands to a list and children pop.
  - --log-level accepts Monolog/PSR-3 levels (debug, info, notice, warning, error, critical, alert, emergency).
  - --status-interval controls how often human-readable progress is printed (default: 1).

TXT;
    fwrite(STDERR, $msg);
}

function parse_csl(?string $value): array
{
    if ($value === null || $value === '') {
        return [];
    }
    $items = array_map('trim', explode(',', $value));
    return array_values(array_filter($items, static fn($item) => $item !== ''));
}

function create_logger(string $level): Logger
{
    $logger = new Logger('relay-table-fuzzer');
    $handler = new StreamHandler('php://stderr', Logger::toMonologLevel($level));
    $format = "[%extra.microtime% %extra.pid% %level_name%] %message% %context%\n";
    $formatter = new LineFormatter($format, null, true, true);
    $handler->setFormatter($formatter);
    $logger->pushProcessor(static function (LogRecord $record): LogRecord {
        $extra = $record->extra;
        $extra['microtime'] = sprintf('%.6f', microtime(true));
        $extra['pid'] = getmypid();
        return $record->with(extra: $extra);
    });
    $logger->pushHandler($handler);
    return $logger;
}

function pick_key(int $keys): string
{
    $idx = mt_rand(0, $keys - 1);
    return 'key:' . $idx;
}

function random_string(int $len): string
{
    $chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    $max = strlen($chars) - 1;
    $out = '';
    for ($i = 0; $i < $len; $i++) {
        $out .= $chars[mt_rand(0, $max)];
    }
    return $out;
}

function random_value(): mixed
{
    $choice = mt_rand(0, 3);
    switch ($choice) {
        case 0:
            return mt_rand(-100000, 100000);
        case 1:
            return mt_rand() / (mt_rand(1, 1000));
        case 2:
            return random_string(mt_rand(1, 24));
        case 3:
            $fields = mt_rand(1, 4);
            $arr = [];
            for ($i = 0; $i < $fields; $i++) {
                $arr['field:' . $i] = random_string(mt_rand(1, 10));
            }
            return $arr;
        default:
            return null;
    }
}

function generate_command(array $ops, int $keys): array
{
    $op = $ops[mt_rand(0, count($ops) - 1)];
    $cmd = ['op' => $op];

    switch ($op) {
        case 'get':
        case 'exists':
        case 'delete':
            $cmd['key'] = pick_key($keys);
            break;
        case 'set':
            $cmd['key'] = pick_key($keys);
            $cmd['value'] = random_value();
            break;
        case 'pluck':
            $cmd['key'] = pick_key($keys);
            $cmd['field'] = 'field:' . mt_rand(0, 3);
            break;
        case 'count':
        case 'namespace':
        case 'clear':
        case 'namespaces':
        case 'clearAll':
            break;
        default:
            $cmd['op'] = 'get';
            $cmd['key'] = pick_key($keys);
            break;
    }

    return $cmd;
}

function execute_command(Table $table, array $cmd, Logger $logger, int $workerId): void
{
    $op = $cmd['op'] ?? '';
    $logger->debug('Executing command', [
        'worker' => $workerId,
        'cmd' => $cmd,
    ]);
    switch ($op) {
        case 'get':
            $table->get((string) $cmd['key']);
            break;
        case 'pluck':
            $table->pluck((string) $cmd['key'], (string) $cmd['field']);
            break;
        case 'set':
            $table->set((string) $cmd['key'], $cmd['value'] ?? null);
            break;
        case 'exists':
            $table->exists((string) $cmd['key']);
            break;
        case 'delete':
            $table->delete((string) $cmd['key']);
            break;
        case 'count':
            $table->count();
            break;
        case 'namespace':
            $table->namespace();
            break;
        case 'clear':
            $table->clear();
            break;
        case 'namespaces':
            Table::namespaces();
            break;
        case 'clearAll':
            Table::clearAll();
            break;
        default:
            break;
    }
}

function print_status(string $message): void
{
    fwrite(STDOUT, $message . "\n");
}

function format_percent(int $done, int $total): float
{
    if ($total <= 0) {
        return 0.0;
    }
    return min(100.0, ($done / $total) * 100.0);
}

function run_random_worker(
    int $workerId,
    int $seed,
    int $ops,
    int $keys,
    array $opSet,
    string $namespace,
    Logger $logger,
    float $statusInterval
): void
{
    mt_srand($seed + $workerId);
    $table = new Table($namespace);
    $start = microtime(true);
    $lastReport = $start;
    $executed = 0;

    for ($i = 0; $i < $ops; $i++) {
        $cmd = generate_command($opSet, $keys);
        try {
            execute_command($table, $cmd, $logger, $workerId);
        } catch (Throwable $e) {
            fwrite(STDERR, "worker {$workerId} error: {$e->getMessage()}\n");
        }
        $executed++;
        $now = microtime(true);
        if ($statusInterval > 0 && ($now - $lastReport) >= $statusInterval) {
            $percent = format_percent($executed, $ops);
            print_status(sprintf(
                'worker %d: %0.2f%% %d/%d commands executed',
                $workerId,
                $percent,
                $executed,
                $ops
            ));
            $lastReport = $now;
        }
    }

    $elapsed = microtime(true) - $start;
    $rate = $elapsed > 0 ? ($executed / $elapsed) : 0.0;
    print_status(sprintf(
        'worker %d done: %d commands in %0.2fs (%0.1f ops/s)',
        $workerId,
        $executed,
        $elapsed,
        $rate
    ));
}
}

function parse_host_port(string $spec): array
{
    $parts = explode(':', $spec, 2);
    $host = $parts[0] !== '' ? $parts[0] : '127.0.0.1';
    $port = isset($parts[1]) && $parts[1] !== '' ? (int) $parts[1] : 6379;
    return [$host, $port];
}

$options = getopt('', [
    'workers::',
    'seed::',
    'ops:',
    'keys::',
    'include::',
    'exclude::',
    'mode::',
    'redis::',
    'list::',
    'log-level::',
    'status-interval::',
    'help::',
]);

if (isset($options['help']) || !isset($options['ops'])) {
    usage();
    exit(isset($options['ops']) ? 0 : 1);
}

$workers = isset($options['workers']) ? (int) $options['workers'] : 0;
$ops = (int) $options['ops'];
$seed = isset($options['seed']) ? (int) $options['seed'] : (int) hrtime(true);
$keys = isset($options['keys']) ? (int) $options['keys'] : 16;
$mode = isset($options['mode']) ? strtolower((string) $options['mode']) : 'random';
$redisSpec = isset($options['redis']) ? (string) $options['redis'] : '127.0.0.1:6379';
$listName = isset($options['list']) ? (string) $options['list'] : 'relay-table-fuzzer';
$logLevel = isset($options['log-level']) ? strtolower((string) $options['log-level']) : 'info';
$statusInterval = isset($options['status-interval']) ? (float) $options['status-interval'] : 1.0;

try {
    $logger = create_logger($logLevel);
} catch (InvalidArgumentException $e) {
    fwrite(STDERR, "Invalid --log-level: {$logLevel}\n");
    exit(1);
}

if ($ops <= 0 || $keys <= 0 || $workers < 0 || $statusInterval <= 0) {
    fwrite(STDERR, "Invalid --ops, --keys, --workers, or --status-interval value.\n");
    exit(1);
}

$allOps = [
    'get', 'pluck', 'set', 'exists', 'delete', 'count', 'namespace', 'clear', 'namespaces', 'clearAll',
];

$include = parse_csl($options['include'] ?? null);
$exclude = parse_csl($options['exclude'] ?? null);

$opSet = $allOps;
if ($include !== []) {
    $opSet = array_values(array_intersect($opSet, $include));
}
if ($exclude !== []) {
    $opSet = array_values(array_diff($opSet, $exclude));
}

if ($opSet === []) {
    fwrite(STDERR, "No operations selected after include/exclude filtering.\n");
    exit(1);
}

$namespace = 'fuzz:' . $seed;
$seedSource = isset($options['seed']) ? 'provided' : 'generated';
$includeRaw = isset($options['include']) ? (string) $options['include'] : '';
$excludeRaw = isset($options['exclude']) ? (string) $options['exclude'] : '';

$rerunParts = [
    './fuzzer',
    '--ops', (string) $ops,
    '--seed', (string) $seed,
    '--workers', (string) $workers,
    '--keys', (string) $keys,
    '--mode', $mode,
    '--log-level', $logLevel,
];
if ($includeRaw !== '') {
    $rerunParts[] = '--include';
    $rerunParts[] = $includeRaw;
}
if ($excludeRaw !== '') {
    $rerunParts[] = '--exclude';
    $rerunParts[] = $excludeRaw;
}
if ($mode === 'queue') {
    $rerunParts[] = '--redis';
    $rerunParts[] = $redisSpec;
    $rerunParts[] = '--list';
    $rerunParts[] = $listName;
}
if (isset($options['status-interval'])) {
    $rerunParts[] = '--status-interval';
    $rerunParts[] = (string) $statusInterval;
}
$rerunCommand = implode(' ', array_map('escapeshellarg', $rerunParts));

$logger->info('Fuzzer run configuration', [
    'mode' => $mode,
    'ops' => $ops,
    'seed' => $seed,
    'seed_source' => $seedSource,
    'workers' => $workers,
    'keys' => $keys,
    'namespace' => $namespace,
    'include' => $include,
    'exclude' => $exclude,
    'op_set' => $opSet,
    'redis' => $redisSpec,
    'list' => $listName,
    'status_interval' => $statusInterval,
    'rerun' => $rerunCommand,
]);

print_status('Relay Table fuzzer starting');
print_status(sprintf('ops: %d', $ops));
print_status(sprintf('workers: %d', $workers));
print_status(sprintf('mode: %s', $mode));
print_status(sprintf('seed: %d (%s)', $seed, $seedSource));
print_status(sprintf('keys: %d', $keys));
print_status(sprintf('namespace: %s', $namespace));
if ($include !== []) {
    print_status(sprintf('include: %s', implode(',', $include)));
}
if ($exclude !== []) {
    print_status(sprintf('exclude: %s', implode(',', $exclude)));
}
print_status(sprintf('status interval: %0.2fs', $statusInterval));
if ($mode === 'queue') {
    print_status(sprintf('redis: %s', $redisSpec));
    print_status(sprintf('list: %s', $listName));
}
print_status(sprintf('op set: %s', implode(',', $opSet)));
print_status(sprintf('rerun: %s', $rerunCommand));

if ($mode === 'queue') {
    if (!class_exists('Redis')) {
        fwrite(STDERR, "Redis extension is required for --mode=queue.\n");
        exit(1);
    }

    [$host, $port] = parse_host_port($redisSpec);
    $redis = new Redis();
    if (!$redis->connect($host, $port, 2.5)) {
        fwrite(STDERR, "Failed to connect to Redis at {$host}:{$port}.\n");
        exit(1);
    }

    $queueName = $listName . ':' . $seed;

    mt_srand($seed);
    for ($i = 0; $i < $ops; $i++) {
        $cmd = generate_command($opSet, $keys);
        $redis->rPush($queueName, json_encode($cmd, JSON_UNESCAPED_SLASHES));
    }

    if ($workers === 0) {
        $table = new Table($namespace);
        $start = microtime(true);
        $lastReport = $start;
        $executed = 0;
        while (true) {
            $payload = $redis->lPop($queueName);
            if ($payload === false) {
                break;
            }
            $cmd = json_decode($payload, true);
            if (!is_array($cmd)) {
                continue;
            }
            try {
                execute_command($table, $cmd, $logger, 0);
            } catch (Throwable $e) {
                fwrite(STDERR, "worker 0 error: {$e->getMessage()}\n");
            }
            $executed++;
            $now = microtime(true);
            if ($statusInterval > 0 && ($now - $lastReport) >= $statusInterval) {
                $percent = format_percent($executed, $ops);
                print_status(sprintf(
                    'worker 0: %0.2f%% %d/%d commands executed',
                    $percent,
                    $executed,
                    $ops
                ));
                $lastReport = $now;
            }
        }
        $elapsed = microtime(true) - $start;
        $rate = $elapsed > 0 ? ($executed / $elapsed) : 0.0;
        print_status(sprintf(
            'worker 0 done: %d commands in %0.2fs (%0.1f ops/s)',
            $executed,
            $elapsed,
            $rate
        ));
        exit(0);
    }

    if (!function_exists('pcntl_fork')) {
        fwrite(STDERR, "pcntl extension is required for workers > 0.\n");
        exit(1);
    }

    $pids = [];
    for ($i = 0; $i < $workers; $i++) {
        $pid = pcntl_fork();
        if ($pid === -1) {
            fwrite(STDERR, "Failed to fork worker {$i}.\n");
            exit(1);
        }
        if ($pid === 0) {
            $table = new Table($namespace);
            $start = microtime(true);
            $lastReport = $start;
            $executed = 0;
            while (true) {
                $payload = $redis->lPop($queueName);
                if ($payload === false) {
                    break;
                }
                $cmd = json_decode($payload, true);
                if (!is_array($cmd)) {
                    continue;
                }
                try {
                    execute_command($table, $cmd, $logger, $i);
                } catch (Throwable $e) {
                    fwrite(STDERR, "worker {$i} error: {$e->getMessage()}\n");
                }
                $executed++;
                $now = microtime(true);
                if ($statusInterval > 0 && ($now - $lastReport) >= $statusInterval) {
                    $percent = format_percent($executed, $ops);
                    print_status(sprintf(
                        'worker %d: %0.2f%% %d/%d commands executed',
                        $i,
                        $percent,
                        $executed,
                        $ops
                    ));
                    $lastReport = $now;
                }
            }
            $elapsed = microtime(true) - $start;
            $rate = $elapsed > 0 ? ($executed / $elapsed) : 0.0;
            print_status(sprintf(
                'worker %d done: %d commands in %0.2fs (%0.1f ops/s)',
                $i,
                $executed,
                $elapsed,
                $rate
            ));
            exit(0);
        }
        $pids[] = $pid;
    }

    foreach ($pids as $pid) {
        pcntl_waitpid($pid, $status);
    }

    print_status('All workers completed.');
    exit(0);
}

if ($mode !== 'random') {
    fwrite(STDERR, "Unknown --mode: {$mode}. Use random or queue.\n");
    exit(1);
}

if ($workers === 0) {
    run_random_worker(0, $seed, $ops, $keys, $opSet, $namespace, $logger, $statusInterval);
    exit(0);
}

if (!function_exists('pcntl_fork')) {
    fwrite(STDERR, "pcntl extension is required for workers > 0.\n");
    exit(1);
}

$pids = [];
for ($i = 0; $i < $workers; $i++) {
    $pid = pcntl_fork();
    if ($pid === -1) {
        fwrite(STDERR, "Failed to fork worker {$i}.\n");
        exit(1);
    }
    if ($pid === 0) {
        run_random_worker($i, $seed, $ops, $keys, $opSet, $namespace, $logger, $statusInterval);
        exit(0);
    }
    $pids[] = $pid;
}

foreach ($pids as $pid) {
    pcntl_waitpid($pid, $status);
}

print_status('All workers completed.');
exit(0);

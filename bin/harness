#!/usr/bin/env php
<?php

declare(strict_types=1);

const CRASH_SIGNALS = [
    SIGSEGV,
    SIGBUS,
    SIGILL,
    SIGABRT,
    SIGFPE,
    SIGTRAP,
];

const SIGNAL_LABELS = [
    SIGSEGV => 'SIGSEGV',
    SIGBUS => 'SIGBUS',
    SIGILL => 'SIGILL',
    SIGABRT => 'SIGABRT',
    SIGFPE => 'SIGFPE',
    SIGTRAP => 'SIGTRAP',
];

function usage(string $script): string
{
    return <<<USAGE
Usage:
  {$script} --php-bin /path/to/php [--php-ini /path/to/php.ini] [-d ini=val] [--mode fuzz|script] [--ops N] [--reduce] [--timeout N] [--timeout-signal SIG] [--only-crashes] [--capture-php-leaks] [--jobs N] [--interval SECONDS] [--repro-tries N] -- <command...>

Dynamic replacements in command arguments and -d values:
  {range}            -> random integer
  {range(lo,hi)}     -> random integer between lo and hi (inclusive)
  {hrtime}           -> hrtime(true)
  {ops}              -> value provided via --ops
USAGE;
}

function render_command(array $command): string
{
    return implode(' ', array_map('escapeshellarg', $command));
}

function signal_label(int $signal): string
{
    return SIGNAL_LABELS[$signal] ?? "SIG{$signal}";
}

function signal_description(int $signal): string
{
    if (function_exists('pcntl_strsignal')) {
        $desc = pcntl_strsignal($signal);
        if (is_string($desc) && $desc !== '') {
            return $desc;
        }
    }

    return '';
}

function replace_dynamic(string $arg): string
{
    $arg = preg_replace_callback('/\{range\((\-?\d+)\s*,\s*(\-?\d+)\)\}/', static function (array $matches): string {
        $lo = (int)$matches[1];
        $hi = (int)$matches[2];
        if ($lo > $hi) {
            [$lo, $hi] = [$hi, $lo];
        }

        return (string)random_int($lo, $hi);
    }, $arg);

    $arg = preg_replace_callback('/\{range\}/', static function (): string {
        return (string)random_int(0, PHP_INT_MAX);
    }, $arg);

    $arg = preg_replace_callback('/\{hrtime\}/', static function (): string {
        return (string)hrtime(true);
    }, $arg);

    return $arg;
}

function apply_ops(string $arg, ?int $ops): string
{
    if ($ops === null) {
        return $arg;
    }

    return str_replace('{ops}', (string)$ops, $arg);
}

function build_php_command(string $phpBin, ?string $phpIni, array $phpArgs, array $runArgs): array
{
    $iniArgs = ($phpIni !== null && $phpIni !== '') ? ['-c', $phpIni] : [];
    return array_merge([$phpBin], $iniArgs, $phpArgs, $runArgs);
}

function create_temp_dir(string $prefix): string
{
    $tmp = tempnam(sys_get_temp_dir(), $prefix);
    if ($tmp === false) {
        fwrite(STDERR, "Failed to create temp path\n");
        exit(1);
    }
    @unlink($tmp);
    if (!mkdir($tmp, 0777, true) && !is_dir($tmp)) {
        fwrite(STDERR, "Failed to create temp dir: {$tmp}\n");
        exit(1);
    }
    return $tmp;
}

function remove_dir_recursive(string $dir): void
{
    if (!is_dir($dir)) {
        return;
    }
    $entries = scandir($dir);
    if ($entries === false) {
        return;
    }
    foreach ($entries as $entry) {
        if ($entry === '.' || $entry === '..') {
            continue;
        }
        $path = $dir . '/' . $entry;
        if (is_dir($path)) {
            remove_dir_recursive($path);
            continue;
        }
        @unlink($path);
    }
    @rmdir($dir);
}

function format_duration(int $seconds): string
{
    $days = intdiv($seconds, 86400);
    $seconds -= $days * 86400;
    $hours = intdiv($seconds, 3600);
    $seconds -= $hours * 3600;
    $minutes = intdiv($seconds, 60);
    $seconds -= $minutes * 60;

    if ($days > 0) {
        return sprintf('%dd %02d:%02d:%02d', $days, $hours, $minutes, $seconds);
    }

    return sprintf('%02d:%02d:%02d', $hours, $minutes, $seconds);
}

function format_bytes(int $bytes): string
{
    $units = ['B', 'K', 'M', 'G', 'T'];
    $value = (float)$bytes;
    $unitIndex = 0;

    while ($value >= 1024 && $unitIndex < count($units) - 1) {
        $value /= 1024;
        $unitIndex++;
    }

    if ($unitIndex === 0) {
        return (string)$bytes;
    }

    $precision = $value >= 10 ? 0 : 1;
    $formatted = number_format($value, $precision, '.', '');
    $formatted = rtrim(rtrim($formatted, '0'), '.');

    return $formatted . $units[$unitIndex];
}

function terminal_width(): int
{
    $columns = getenv('COLUMNS');
    if (is_string($columns) && ctype_digit($columns)) {
        return max(60, (int)$columns);
    }

    return 80;
}

function truncate_text(string $text, int $width): string
{
    if ($width <= 0) {
        return '';
    }

    if (strlen($text) <= $width) {
        return $text;
    }

    if ($width <= 3) {
        return substr($text, 0, $width);
    }

    return substr($text, 0, $width - 3) . '...';
}

function pad_line(string $text, int $width): string
{
    $text = truncate_text($text, $width);
    return str_pad($text, $width);
}

function two_column(string $left, string $right, int $width, int $gap = 3, ?int $leftWidth = null): string
{
    $gap = max(1, $gap);
    if ($leftWidth === null) {
        $leftWidth = intdiv($width - $gap, 2);
    }

    $leftWidth = max(1, min($leftWidth, $width - $gap - 1));
    $rightWidth = max(1, $width - $gap - $leftWidth);

    $left = str_pad(truncate_text($left, $leftWidth), $leftWidth);
    $right = str_pad(truncate_text($right, $rightWidth), $rightWidth);

    return $left . str_repeat(' ', $gap) . $right;
}

function format_label_value(string $label, string $value, int $labelWidth = 12): string
{
    return str_pad($label, $labelWidth) . ': ' . $value;
}

function count_reproducer_dirs(string $reproducersDir): array
{
    if (!is_dir($reproducersDir)) {
        return ['total' => 0, 'reproducing' => 0];
    }

    $total = 0;
    $reproducing = 0;
    $entries = scandir($reproducersDir);
    if ($entries === false) {
        return ['total' => 0, 'reproducing' => 0];
    }

    foreach ($entries as $entry) {
        if ($entry === '.' || $entry === '..') {
            continue;
        }
        $dir = $reproducersDir . '/' . $entry;
        if (!is_dir($dir)) {
            continue;
        }
        if ($entry === 'reproducing' || $entry === 'non-reproducing') {
            $subEntries = scandir($dir);
            if ($subEntries === false) {
                continue;
            }
            foreach ($subEntries as $subEntry) {
                if ($subEntry === '.' || $subEntry === '..') {
                    continue;
                }
                if (!is_dir($dir . '/' . $subEntry)) {
                    continue;
                }
                $total++;
                if ($entry === 'reproducing') {
                    $reproducing++;
                }
            }
            continue;
        }
        $total++;
    }

    return ['total' => $total, 'reproducing' => $reproducing];
}

function render_screen(array $stats, ?int $currentOps, string $mode): void
{
    $width = terminal_width();
    $now = microtime(true);
    $elapsed = format_duration((int)($now - $stats['start_time']));
    $sinceFailure = $stats['last_failure_time'] !== null
        ? format_duration((int)($now - $stats['last_failure_time']))
        : 'never';

    $lines = [];
    $lines[] = str_repeat('=', $width);
    $title = 'relay-table-fuzzer harness';
    $lines[] = pad_line(str_pad($title, $width, ' ', STR_PAD_BOTH), $width);
    $lines[] = str_repeat('-', $width);
    $activeJobs = $stats['active_jobs'] ?? 1;
    $opsLabel = $currentOps !== null ? (string)$currentOps : 'n/a';
    $reproducersTotal = $stats['reproducers'] ?? 0;
    $reproducersReproducing = $stats['reproducers_reproducing'] ?? 0;
    $reproducersLabel = number_format($reproducersTotal) . ' (' . number_format($reproducersReproducing) . ' reproducing)';
    $pairs = [
        [
            format_label_value('Elapsed', $elapsed),
            format_label_value('Runs', number_format($stats['runs'])),
        ],
        [
            format_label_value('Jobs', (string)$activeJobs),
            format_label_value('Reproducers', $reproducersLabel),
        ],
        [
            format_label_value('Last failure', $sinceFailure),
            format_label_value('Reductions', number_format($stats['reductions'])),
        ],
        [
            format_label_value('Ops', $opsLabel),
            format_label_value('Mode', $mode),
        ],
    ];
    $maxLeft = 0;
    $maxRight = 0;
    foreach ($pairs as [$left, $right]) {
        $maxLeft = max($maxLeft, strlen($left));
        $maxRight = max($maxRight, strlen($right));
    }
    $gap = 3;
    $leftWidth = min($maxLeft, max(1, $width - $gap - 1));
    if ($maxRight > 0 && $leftWidth + $gap + $maxRight > $width) {
        $leftWidth = max(1, $width - $gap - $maxRight);
    }
    foreach ($pairs as [$left, $right]) {
        $lines[] = two_column($left, $right, $width, $gap, $leftWidth);
    }
    $memoryLine = 'Relay mem: n/a';
    $relayMemory = $stats['relay_memory'] ?? null;
    if (is_array($relayMemory)) {
        $used = format_bytes((int)($relayMemory['used'] ?? 0));
        $total = format_bytes((int)($relayMemory['total'] ?? 0));
        $memoryLine = "Relay mem: {$used}/{$total}";
    }
    $lines[] = pad_line($memoryLine, $width);
    $lastFailure = $stats['last_failure_summary'] !== '' ? $stats['last_failure_summary'] : 'none';
    $event = $stats['last_event'] !== '' ? $stats['last_event'] : 'none';
    $lines[] = two_column(
        format_label_value('Last crash', $lastFailure),
        format_label_value('Event', $event),
        $width,
        $gap,
        $leftWidth
    );
    $lastRepro = $stats['last_reproducer'] !== '' ? $stats['last_reproducer'] : 'n/a';
    $lines[] = pad_line("Last reproducer: {$lastRepro}", $width);
    $lines[] = str_repeat('-', $width);
    $command = $stats['last_command'] ?? '';
    $lines[] = pad_line("Command: {$command}", $width);
    $lines[] = str_repeat('=', $width);

    fwrite(STDOUT, "\033[2J\033[H" . implode("\n", $lines) . "\n");
    fflush(STDOUT);
}

function maybe_render_screen(
    array $stats,
    ?int $currentOps,
    string $mode,
    float $interval,
    float &$lastRenderTime,
    bool $force = false
): void {
    $now = microtime(true);
    if (!$force && $interval > 0 && ($now - $lastRenderTime) < $interval) {
        return;
    }

    $lastRenderTime = $now;
    render_screen($stats, $currentOps, $mode);
}

function find_core_dumps(string $phpBin, ?int $pid, ?float $startTime = null): array
{
    $binary = basename($phpBin);
    if ($pid !== null) {
        $pattern = "/tmp/core.{$binary}.{$pid}.*";
        $cores = glob($pattern);
        return $cores !== false ? $cores : [];
    }

    if ($startTime === null) {
        return [];
    }

    $pattern = "/tmp/core.{$binary}.*";
    $cores = glob($pattern);
    if ($cores === false) {
        return [];
    }

    $cutoff = max(0, (int)$startTime - 1);
    return array_values(array_filter($cores, static function (string $path) use ($cutoff): bool {
        $mtime = @filemtime($path);
        return $mtime !== false && $mtime >= $cutoff;
    }));
}

function parse_timeout_signal(?string $value): ?array
{
    if ($value === null || $value === '') {
        return null;
    }

    if (ctype_digit($value)) {
        return ['arg' => $value, 'num' => (int)$value];
    }

    $name = strtoupper($value);
    if (strpos($name, 'SIG') !== 0) {
        $name = 'SIG' . $name;
    }

    if (!defined($name)) {
        return null;
    }

    return ['arg' => $name, 'num' => (int)constant($name)];
}

function wrap_timeout_command(array $command, ?int $maxSeconds, ?string $timeoutSignalArg): array
{
    if ($maxSeconds === null) {
        return $command;
    }

    $wrapped = ['timeout'];
    if ($timeoutSignalArg !== null) {
        $wrapped[] = '--signal=' . $timeoutSignalArg;
    }
    $wrapped[] = (string)$maxSeconds;

    return array_merge($wrapped, $command);
}

function is_timeout_exit(int $exitCode, ?int $timeoutSignal): bool
{
    if ($exitCode === 124) {
        return true;
    }

    if ($timeoutSignal !== null && $exitCode === 128 + $timeoutSignal) {
        return true;
    }

    return false;
}

function run_command(
    array $fullCommand,
    string $phpBin,
    ?int $maxSeconds,
    ?string $timeoutSignalArg,
    ?int $timeoutSignal,
    bool $onlyCrashes
): array {
    $stdoutPath = tempnam(sys_get_temp_dir(), 'relay-harness-out-');
    $stderrPath = tempnam(sys_get_temp_dir(), 'relay-harness-err-');
    $descriptorSpec = [
        0 => ['file', 'php://stdin', 'r'],
        1 => ['file', $stdoutPath !== false ? $stdoutPath : 'php://stdout', 'w'],
        2 => ['file', $stderrPath !== false ? $stderrPath : 'php://stderr', 'w'],
    ];

    $execCommand = wrap_timeout_command($fullCommand, $maxSeconds, $timeoutSignalArg);
    $process = proc_open($execCommand, $descriptorSpec, $pipes);
    if (!is_resource($process)) {
        fwrite(STDERR, "Failed to start process\n");
        exit(1);
    }

    $status = proc_get_status($process);
    $pid = $status['pid'] ?? null;
    if ($maxSeconds !== null) {
        $pid = null;
    }
    $start = microtime(true);

    while ($status['running']) {
        usleep(10000);
        $status = proc_get_status($process);
    }

    if ($status['running']) {
        for ($i = 0; $i < 50; $i++) {
            usleep(100000);
            $status = proc_get_status($process);
            if (!$status['running']) {
                break;
            }
        }
    }

    $exitCode = proc_close($process);
    $timedOut = $maxSeconds !== null ? is_timeout_exit($exitCode, $timeoutSignal) : false;

    $signal = null;
    if (($status['signaled'] ?? false) && isset($status['termsig'])) {
        $signal = (int)$status['termsig'];
    } elseif ($exitCode !== 0 && $exitCode > 128) {
        $signal = $exitCode - 128;
    }

    if ($timedOut) {
        $signal = null;
    }

    $usesTimeout = $maxSeconds !== null;
    $coreFiles = find_core_dumps($phpBin, $usesTimeout ? null : $pid, $start);
    $isCrash = ($signal !== null && in_array($signal, CRASH_SIGNALS, true)) || $coreFiles !== [];
    if (!$onlyCrashes) {
        $isCrash = $timedOut || $isCrash;
    }

    return [
        'exit_code' => $exitCode,
        'signal' => $signal,
        'pid' => $pid,
        'timed_out' => $timedOut,
        'is_crash' => $isCrash,
        'core_files' => $coreFiles,
        'timeout_signal' => $timedOut ? $timeoutSignalArg : null,
        'stdout_path' => $stdoutPath !== false ? $stdoutPath : null,
        'stderr_path' => $stderrPath !== false ? $stderrPath : null,
    ];
}

function start_command(
    array $fullCommand,
    string $phpBin,
    ?int $maxSeconds,
    ?string $timeoutSignalArg,
    ?int $timeoutSignal
): array {
    $stdoutPath = tempnam(sys_get_temp_dir(), 'relay-harness-out-');
    $stderrPath = tempnam(sys_get_temp_dir(), 'relay-harness-err-');
    $descriptorSpec = [
        0 => ['file', 'php://stdin', 'r'],
        1 => ['file', $stdoutPath !== false ? $stdoutPath : 'php://stdout', 'w'],
        2 => ['file', $stderrPath !== false ? $stderrPath : 'php://stderr', 'w'],
    ];

    $execCommand = wrap_timeout_command($fullCommand, $maxSeconds, $timeoutSignalArg);
    $process = proc_open($execCommand, $descriptorSpec, $pipes);
    if (!is_resource($process)) {
        fwrite(STDERR, "Failed to start process\n");
        exit(1);
    }

    $status = proc_get_status($process);

    return [
        'process' => $process,
        'pid' => $maxSeconds !== null ? null : ($status['pid'] ?? null),
        'start_time' => microtime(true),
        'php_bin' => $phpBin,
        'stdout_path' => $stdoutPath !== false ? $stdoutPath : null,
        'stderr_path' => $stderrPath !== false ? $stderrPath : null,
        'timed_out' => false,
        'cancelled' => false,
        'uses_timeout' => $maxSeconds !== null,
        'timeout_signal' => $timeoutSignal,
        'timeout_signal_arg' => $timeoutSignalArg,
    ];
}

function finalize_command(array $job, array $status, ?int $timeoutSignal, bool $onlyCrashes): array
{
    $exitCode = proc_close($job['process']);
    $timedOut = (!empty($job['uses_timeout']) && is_timeout_exit($exitCode, $timeoutSignal));

    $signal = null;
    if (($status['signaled'] ?? false) && isset($status['termsig'])) {
        $signal = (int)$status['termsig'];
    } elseif ($exitCode !== 0 && $exitCode > 128) {
        $signal = $exitCode - 128;
    }

    if ($timedOut) {
        $signal = null;
    }

    $coreFiles = find_core_dumps(
        $job['php_bin'],
        empty($job['uses_timeout']) ? $job['pid'] : null,
        $job['start_time'] ?? null
    );
    $isCrash = ($signal !== null && in_array($signal, CRASH_SIGNALS, true)) || $coreFiles !== [];
    if (!$onlyCrashes) {
        $isCrash = ($job['timed_out'] || $timedOut) || $isCrash;
    }

    return [
        'exit_code' => $exitCode,
        'signal' => $signal,
        'pid' => $job['pid'],
        'timed_out' => $job['timed_out'] || $timedOut,
        'is_crash' => $isCrash,
        'core_files' => $coreFiles,
        'timeout_signal' => $timedOut ? ($job['timeout_signal_arg'] ?? null) : null,
        'stdout_path' => $job['stdout_path'],
        'stderr_path' => $job['stderr_path'],
    ];
}

function poll_command(array &$job, ?int $timeoutSignal, bool $onlyCrashes): ?array
{
    $status = proc_get_status($job['process']);
    if ($status['running']) {
        if (!empty($job['cancelled'])) {
            proc_terminate($job['process']);
            $cancelAt = $job['cancel_requested_at'] ?? $job['start_time'];
            if ((microtime(true) - $cancelAt) >= 1.0) {
                proc_terminate($job['process'], SIGKILL);
            }
            return null;
        }

        return null;
    }

    if ($status['running']) {
        for ($i = 0; $i < 10; $i++) {
            usleep(100000);
            $status = proc_get_status($job['process']);
            if (!$status['running']) {
                break;
            }
        }
    }

    return finalize_command($job, $status, $timeoutSignal, $onlyCrashes);
}

function cancel_command(array &$job): void
{
    if ($job['cancelled']) {
        return;
    }

    $job['cancelled'] = true;
    $job['cancel_requested_at'] = microtime(true);
    proc_terminate($job['process']);
}

function create_job(
    array $commandArgs,
    ?int $currentOps,
    string $phpBin,
    ?string $phpIni,
    array $phpArgs,
    int $jobId,
    ?int $maxSeconds,
    ?string $timeoutSignalArg,
    ?int $timeoutSignal
): array {
    $dynamicArgs = array_map('replace_dynamic', $commandArgs);
    $dynamicPhpArgs = array_map('replace_dynamic', $phpArgs);
    $runArgs = array_map(static fn(string $arg): string => apply_ops($arg, $currentOps), $dynamicArgs);
    $fullCommand = build_php_command($phpBin, $phpIni, $dynamicPhpArgs, $runArgs);

    $job = start_command($fullCommand, $phpBin, $maxSeconds, $timeoutSignalArg, $timeoutSignal);
    $job['id'] = $jobId;
    $job['dynamic_args'] = $dynamicArgs;
    $job['php_args'] = $dynamicPhpArgs;
    $job['full_command'] = $fullCommand;
    $job['command_string'] = render_command(wrap_timeout_command($fullCommand, $maxSeconds, $timeoutSignalArg));
    $job['ops'] = $currentOps;

    return $job;
}

function normalize_fuzzer_mode(string $mode): string
{
    $mode = strtolower(trim($mode));
    if ($mode === '') {
        return 'random';
    }
    if (str_starts_with($mode, 'script')) {
        $parts = explode(':', $mode, 2);
        if (isset($parts[1]) && $parts[1] !== '') {
            return $parts[1];
        }
        return 'random';
    }
    return $mode;
}

function build_script_mode_args(array $runArgs): array
{
    $args = [];
    $mode = 'random';
    $sawMode = false;
    $count = count($runArgs);

    for ($i = 0; $i < $count; $i++) {
        $arg = $runArgs[$i];
        if ($arg === '--mode') {
            $sawMode = true;
            $mode = normalize_fuzzer_mode($runArgs[$i + 1] ?? '');
            $args[] = '--mode';
            $args[] = 'script:' . $mode;
            $i++;
            continue;
        }
        if (str_starts_with($arg, '--mode=')) {
            $sawMode = true;
            $value = substr($arg, strlen('--mode='));
            $mode = normalize_fuzzer_mode($value);
            $args[] = '--mode=script:' . $mode;
            continue;
        }
        $args[] = $arg;
    }

    if (!$sawMode) {
        $args[] = '--mode';
        $args[] = 'script:' . $mode;
    }

    return [$args, $mode];
}

function should_generate_script(array $runArgs): bool
{
    if ($runArgs === []) {
        return false;
    }
    $binary = basename($runArgs[0]);
    return $binary === 'fuzzer' || $binary === 'fuzzer.php';
}

function capture_script_artifacts(string $sourceDir, string $destinationDir): void
{
    $files = [
        'reproducer.php',
        'reproducer-generate.stderr',
        'run-reproducer.sh',
    ];
    foreach ($files as $file) {
        $source = $sourceDir . '/' . $file;
        if (!is_file($source)) {
            continue;
        }
        $dest = $destinationDir . '/' . $file;
        if (file_exists($dest)) {
            @unlink($dest);
        }
        @copy($source, $dest);
    }
}

function generate_reproducer_script(
    string $jobDir,
    string $phpBin,
    ?string $phpIni,
    array $phpArgs,
    array $runArgs,
    string $finalCommand
): void {
    if (!should_generate_script($runArgs)) {
        return;
    }

    [$scriptArgs, $mode] = build_script_mode_args($runArgs);
    $fullCommand = build_php_command($phpBin, $phpIni, $phpArgs, $scriptArgs);
    $scriptPath = $jobDir . '/reproducer.php';
    $stderrPath = $jobDir . '/reproducer-generate.stderr';

    $contextLines = [
        'generated by relay-table-fuzzer harness',
        'captured: ' . date('c'),
        'fuzzer mode: ' . $mode,
        'fuzzer command: ' . $finalCommand,
        'script command: ' . render_command($fullCommand),
        'php bin: ' . $phpBin,
    ];
    if ($phpIni !== null && $phpIni !== '') {
        $contextLines[] = 'php ini: ' . $phpIni;
    }
    if ($phpArgs !== []) {
        $contextLines[] = 'php args: ' . render_command($phpArgs);
    }

    $env = getenv();
    if (!is_array($env)) {
        $env = [];
    }
    $env['RELAY_FUZZER_CONTEXT'] = implode("\n", $contextLines);

    $descriptorSpec = [
        0 => ['file', '/dev/null', 'r'],
        1 => ['file', $scriptPath, 'w'],
        2 => ['file', $stderrPath, 'w'],
    ];

    $process = proc_open($fullCommand, $descriptorSpec, $pipes, null, $env);
    if (!is_resource($process)) {
        file_put_contents($stderrPath, "failed to start script generator\n");
        return;
    }

    $status = proc_get_status($process);
    while ($status['running']) {
        usleep(10000);
        $status = proc_get_status($process);
    }

    $exitCode = proc_close($process);
    if ($exitCode !== 0) {
        file_put_contents($stderrPath, "script generator exit code: {$exitCode}\n", FILE_APPEND);
        return;
    }

    $runnerPath = $jobDir . '/run-reproducer.sh';
    $runnerCommand = build_php_command($phpBin, $phpIni, $phpArgs, ['reproducer.php']);
    $runnerLines = [
        '#!/usr/bin/env sh',
        '',
        '# Auto-generated by relay-table-fuzzer harness.',
        'exec ' . render_command($runnerCommand),
    ];
    file_put_contents($runnerPath, implode("\n", $runnerLines) . "\n");

    @chmod($scriptPath, 0755);
    @chmod($runnerPath, 0755);
    if (is_file($stderrPath) && filesize($stderrPath) === 0) {
        @unlink($stderrPath);
    }
}

function create_script_job(
    array $commandArgs,
    ?int $currentOps,
    string $phpBin,
    ?string $phpIni,
    array $phpArgs,
    int $jobId,
    ?int $maxSeconds,
    ?string $timeoutSignalArg,
    ?int $timeoutSignal
): array {
    $dynamicArgs = array_map('replace_dynamic', $commandArgs);
    $dynamicPhpArgs = array_map('replace_dynamic', $phpArgs);
    $runArgs = array_map(static fn(string $arg): string => apply_ops($arg, $currentOps), $dynamicArgs);

    $generatorCommand = build_php_command($phpBin, $phpIni, $dynamicPhpArgs, $runArgs);
    $generatorCommandString = render_command($generatorCommand);

    $scriptDir = create_temp_dir('relay-harness-script-');
    generate_reproducer_script($scriptDir, $phpBin, $phpIni, $dynamicPhpArgs, $runArgs, $generatorCommandString);

    $scriptPath = $scriptDir . '/reproducer.php';
    if (!is_file($scriptPath)) {
        $stderrPath = $scriptDir . '/reproducer-generate.stderr';
        $message = '';
        if (is_file($stderrPath)) {
            $message = trim((string)file_get_contents($stderrPath));
        }
        fwrite(STDERR, "Script generation failed. {$message}\n");
        exit(1);
    }

    $scriptCommand = build_php_command($phpBin, $phpIni, $dynamicPhpArgs, [$scriptPath]);
    $job = start_command($scriptCommand, $phpBin, $maxSeconds, $timeoutSignalArg, $timeoutSignal);
    $job['id'] = $jobId;
    $job['dynamic_args'] = $dynamicArgs;
    $job['php_args'] = $dynamicPhpArgs;
    $job['full_command'] = $scriptCommand;
    $job['command_string'] = render_command(wrap_timeout_command($scriptCommand, $maxSeconds, $timeoutSignalArg));
    $job['ops'] = $currentOps;
    $job['script_dir'] = $scriptDir;
    $job['script_path'] = $scriptPath;
    $job['generator_command'] = $generatorCommandString;

    return $job;
}

function reduce_ops(
    int $maxOps,
    array $dynamicArgs,
    string $phpBin,
    ?string $phpIni,
    array $phpArgs,
    array &$stats,
    string $jobDir,
    ?int $maxSeconds,
    ?string $timeoutSignalArg,
    ?int $timeoutSignal,
    bool $onlyCrashes,
    float $renderInterval,
    float &$lastRenderTime
): int {
    $low = 1;
    $high = $maxOps;

    while ($low < $high) {
        $mid = intdiv($low + $high, 2);
        $runArgs = array_map(static fn(string $arg): string => apply_ops($arg, $mid), $dynamicArgs);
        $fullCommand = build_php_command($phpBin, $phpIni, $phpArgs, $runArgs);
        $commandString = render_command(wrap_timeout_command($fullCommand, $maxSeconds, $timeoutSignalArg));

        $result = run_command($fullCommand, $phpBin, $maxSeconds, $timeoutSignalArg, $timeoutSignal, $onlyCrashes);
        $stats['runs']++;
        $stats['last_command'] = $commandString;
        $stats['last_event'] = "reducing ops: {$mid}";
        if ($result['is_crash']) {
            $stats['last_failure_time'] = microtime(true);
            $stats['last_failure_summary'] = build_failure_summary($result);
            $stats['last_event'] = "reducer crash at ops {$mid}";
            $movedCores = move_core_dumps($result['core_files'], $jobDir);
            generate_gdb_backtraces($movedCores, $jobDir, $phpBin);
        }
        cleanup_output_files($result);
        maybe_render_screen($stats, $mid, 'reducing', $renderInterval, $lastRenderTime, $result['is_crash']);
        if ($result['is_crash']) {
            $high = $mid;
            continue;
        }

        $low = $mid + 1;
    }

    return $low;
}

function reduce_ops_script(
    int $maxOps,
    array $dynamicArgs,
    string $phpBin,
    ?string $phpIni,
    array $phpArgs,
    array &$stats,
    string $jobDir,
    ?int $maxSeconds,
    ?string $timeoutSignalArg,
    ?int $timeoutSignal,
    bool $onlyCrashes,
    float $renderInterval,
    float &$lastRenderTime
): int {
    $low = 1;
    $high = $maxOps;

    while ($low < $high) {
        $mid = intdiv($low + $high, 2);
        $runArgs = array_map(static fn(string $arg): string => apply_ops($arg, $mid), $dynamicArgs);
        $generatorCommand = build_php_command($phpBin, $phpIni, $phpArgs, $runArgs);
        $generatorCommandString = render_command($generatorCommand);

        $scriptDir = create_temp_dir('relay-harness-reduce-');
        generate_reproducer_script($scriptDir, $phpBin, $phpIni, $phpArgs, $runArgs, $generatorCommandString);
        $scriptPath = $scriptDir . '/reproducer.php';
        if (!is_file($scriptPath)) {
            remove_dir_recursive($scriptDir);
            fwrite(STDERR, "Script generation failed during reduction\n");
            exit(1);
        }

        $scriptCommand = build_php_command($phpBin, $phpIni, $phpArgs, [$scriptPath]);
        $commandString = render_command(wrap_timeout_command($scriptCommand, $maxSeconds, $timeoutSignalArg));

        $result = run_command($scriptCommand, $phpBin, $maxSeconds, $timeoutSignalArg, $timeoutSignal, $onlyCrashes);
        $stats['runs']++;
        $stats['last_command'] = $commandString;
        $stats['last_event'] = "reducing ops: {$mid}";
        if ($result['is_crash']) {
            $stats['last_failure_time'] = microtime(true);
            $stats['last_failure_summary'] = build_failure_summary($result);
            $stats['last_event'] = "reducer crash at ops {$mid}";
            $movedCores = move_core_dumps($result['core_files'], $jobDir);
            generate_gdb_backtraces($movedCores, $jobDir, $phpBin);
        }
        cleanup_output_files($result);
        remove_dir_recursive($scriptDir);
        maybe_render_screen($stats, $mid, 'reducing', $renderInterval, $lastRenderTime, $result['is_crash']);
        if ($result['is_crash']) {
            $high = $mid;
            continue;
        }

        $low = $mid + 1;
    }

    return $low;
}

function resolve_php_binary_for_gdb(string $phpBin): ?string
{
    $resolved = $phpBin;
    if (is_link($phpBin)) {
        $link = readlink($phpBin);
        if ($link !== false) {
            if (substr($link, 0, 1) !== '/') {
                $link = dirname($phpBin) . '/' . $link;
            }
            $resolved = $link;
        }
    }

    $real = realpath($resolved);
    if ($real !== false) {
        $resolved = $real;
    }

    return is_file($resolved) ? $resolved : null;
}

function find_gdb_binary(): ?string
{
    $output = [];
    $exitCode = 0;
    @exec('command -v gdb', $output, $exitCode);
    if ($exitCode !== 0 || $output === []) {
        return null;
    }

    $path = trim($output[0] ?? '');
    return $path !== '' ? $path : null;
}

function run_gdb_backtrace(string $gdb, string $phpPath, string $coreFile, string $tracePath, string $command): void
{
    $descriptorSpec = [
        0 => ['file', '/dev/null', 'r'],
        1 => ['file', $tracePath, 'w'],
        2 => ['file', $tracePath . '.err', 'w'],
    ];
    $gdbCommand = [
        $gdb,
        '-batch',
        '-ex',
        'set pagination off',
        '-ex',
        $command,
        $phpPath,
        $coreFile,
    ];
    $process = proc_open($gdbCommand, $descriptorSpec, $pipes);
    if (!is_resource($process)) {
        file_put_contents($tracePath, "failed to start gdb\n");
        return;
    }

    $status = proc_get_status($process);
    while (($status['running'] ?? false) === true) {
        usleep(10000);
        $status = proc_get_status($process);
    }

    proc_close($process);
}

function generate_gdb_backtraces(array $coreFiles, string $destinationDir, string $phpBin): void
{
    if ($coreFiles === []) {
        return;
    }

    $gdb = find_gdb_binary();
    $phpPath = resolve_php_binary_for_gdb($phpBin);

    $suffix = count($coreFiles) > 1;
    foreach ($coreFiles as $coreFile) {
        $base = basename($coreFile);
        $fullTracePath = $destinationDir . '/' . ($suffix ? "gdb-backtrace-{$base}.txt" : 'gdb-backtrace.txt');
        $simpleTracePath = $destinationDir . '/' . ($suffix ? "gdb-backtrace-simple-{$base}.txt" : 'gdb-backtrace-simple.txt');

        if ($gdb === null) {
            file_put_contents($fullTracePath, "gdb not found in PATH\n");
            file_put_contents($simpleTracePath, "gdb not found in PATH\n");
            continue;
        }

        if ($phpPath === null) {
            file_put_contents($fullTracePath, "php binary not found for gdb\n");
            file_put_contents($simpleTracePath, "php binary not found for gdb\n");
            continue;
        }

        run_gdb_backtrace($gdb, $phpPath, $coreFile, $fullTracePath, 'thread apply all bt full');
        run_gdb_backtrace($gdb, $phpPath, $coreFile, $simpleTracePath, 'thread apply all bt');
    }
}

function move_core_dumps(array $coreFiles, string $destinationDir): array
{
    $moved = [];
    foreach ($coreFiles as $coreFile) {
        $target = $destinationDir . '/' . basename($coreFile);
        if (@rename($coreFile, $target)) {
            $moved[] = $target;
            continue;
        }

        if (@copy($coreFile, $target)) {
            @unlink($coreFile);
            $moved[] = $target;
        }
    }

    return $moved;
}

function cleanup_output_files(array $result): void
{
    foreach (['stdout_path', 'stderr_path'] as $key) {
        $path = $result[$key] ?? null;
        if (is_string($path) && $path !== '' && file_exists($path)) {
            @unlink($path);
        }
    }
}

function move_output_files(array $result, string $destinationDir): array
{
    $moved = [];
    $mapping = [
        'stdout_path' => 'stdout.log',
        'stderr_path' => 'stderr.log',
    ];

    foreach ($mapping as $key => $targetName) {
        $path = $result[$key] ?? null;
        if (!is_string($path) || $path === '' || !file_exists($path)) {
            continue;
        }

        $target = $destinationDir . '/' . $targetName;
        if (file_exists($target)) {
            @unlink($target);
        }
        if (@rename($path, $target)) {
            $moved[] = $targetName;
            continue;
        }

        if (@copy($path, $target)) {
            @unlink($path);
            $moved[] = $targetName;
        }
    }

    return $moved;
}

function move_reproducer_dir(string $jobDir, string $reproducersDir, bool $reproduced): string
{
    $bucket = $reproduced ? 'reproducing' : 'non-reproducing';
    $bucketDir = $reproducersDir . '/' . $bucket;
    if (!is_dir($bucketDir)) {
        mkdir($bucketDir, 0777, true);
    }

    $targetDir = $bucketDir . '/' . basename($jobDir);
    if (@rename($jobDir, $targetDir)) {
        return $targetDir;
    }

    return $jobDir;
}

function parse_relay_memory_from_output(?string $stdoutPath): ?array
{
    if (!is_string($stdoutPath) || $stdoutPath === '' || !is_file($stdoutPath)) {
        return null;
    }

    $lines = @file($stdoutPath, FILE_IGNORE_NEW_LINES);
    if ($lines === false) {
        return null;
    }

    $prefix = 'RELAY_MEMORY_JSON:';
    for ($i = count($lines) - 1; $i >= 0; $i--) {
        $line = trim($lines[$i]);
        if ($line === '') {
            continue;
        }
        if (strpos($line, $prefix) === 0) {
            $line = trim(substr($line, strlen($prefix)));
        }
        if ($line === '') {
            continue;
        }
        $data = json_decode($line, true);
        if (!is_array($data)) {
            continue;
        }
        if (!isset($data['total'], $data['limit'], $data['active'], $data['used'])) {
            continue;
        }
        return $data;
    }

    return null;
}

function parse_php_leak_count_from_file(?string $path): ?int
{
    if (!is_string($path) || $path === '' || !is_file($path)) {
        return null;
    }

    $lines = @file($path, FILE_IGNORE_NEW_LINES);
    if ($lines === false) {
        return null;
    }

    for ($i = count($lines) - 1; $i >= 0; $i--) {
        $line = trim($lines[$i]);
        if ($line === '') {
            continue;
        }
        if (preg_match('/^===\s*Total\s+(\d+)\s+memory\s+leaks\s+detected\s+===/i', $line, $matches)) {
            return (int)$matches[1];
        }
    }

    return null;
}

function parse_php_leak_count(?string $stdoutPath, ?string $stderrPath): ?int
{
    $count = parse_php_leak_count_from_file($stderrPath);
    if ($count !== null) {
        return $count;
    }

    return parse_php_leak_count_from_file($stdoutPath);
}

function build_failure_summary(array $result): string
{
    if (!empty($result['timed_out'])) {
        return 'TIMEOUT';
    }

    if (!empty($result['core_files'])) {
        $core = basename($result['core_files'][0]);
        return "core {$core}";
    }

    if ($result['signal'] !== null) {
        return signal_label($result['signal']);
    }

    return 'EXIT_' . $result['exit_code'];
}

function ensure_core_ulimit_unlimited(): void
{
    $output = [];
    $exitCode = 0;
    exec('sh -c "ulimit -c"', $output, $exitCode);
    $value = $output !== [] ? trim($output[0]) : '';

    if ($exitCode !== 0 || $value !== 'unlimited') {
        fwrite(STDERR, "Core dump ulimit is not unlimited (ulimit -c returned \"{$value}\").\n");
        fwrite(STDERR, "Set it with: ulimit -c unlimited\n");
        exit(1);
    }
}

$argv = $_SERVER['argv'];
$argc = $_SERVER['argc'];

$phpBin = null;
$phpIni = null;
$phpArgs = [];
$ops = null;
$reduce = false;
$harnessMode = 'fuzz';
$onlyCrashes = false;
$capturePhpLeaks = false;
$maxSeconds = null;
$timeoutSignalArg = null;
$timeoutSignal = null;
$jobs = 1;
$renderInterval = 1.0;
$reproTries = 1;
$commandArgs = [];

for ($i = 1; $i < $argc; $i++) {
    $arg = $argv[$i];
    if ($arg === '--') {
        $commandArgs = array_slice($argv, $i + 1);
        break;
    }

    if ($arg === '--help' || $arg === '-h') {
        fwrite(STDOUT, usage($argv[0]) . "\n");
        exit(0);
    }

    if ($arg === '--php-bin') {
        $phpBin = $argv[++$i] ?? null;
        continue;
    }

    if ($arg === '--php-ini') {
        $phpIni = $argv[++$i] ?? null;
        continue;
    }

    if ($arg === '-d') {
        $value = $argv[++$i] ?? null;
        if ($value === null || $value === '') {
            fwrite(STDERR, "-d requires a non-empty ini=value\n");
            fwrite(STDERR, usage($argv[0]) . "\n");
            exit(1);
        }
        $phpArgs[] = '-d';
        $phpArgs[] = $value;
        continue;
    }

    if (str_starts_with($arg, '-d')) {
        $value = substr($arg, 2);
        if ($value === '') {
            fwrite(STDERR, "-d requires a non-empty ini=value\n");
            fwrite(STDERR, usage($argv[0]) . "\n");
            exit(1);
        }
        $phpArgs[] = '-d';
        $phpArgs[] = $value;
        continue;
    }

    if ($arg === '--ops') {
        $ops = $argv[++$i] ?? null;
        $ops = is_numeric($ops) ? (int)$ops : null;
        continue;
    }

    if ($arg === '--reduce') {
        $reduce = true;
        continue;
    }

    if ($arg === '--mode') {
        $harnessMode = strtolower((string) ($argv[++$i] ?? ''));
        continue;
    }

    if (str_starts_with($arg, '--mode=')) {
        $harnessMode = strtolower(substr($arg, strlen('--mode=')));
        continue;
    }

    if ($arg === '--only-crashes') {
        $onlyCrashes = true;
        continue;
    }

    if ($arg === '--capture-php-leaks') {
        $capturePhpLeaks = true;
        continue;
    }

    if ($arg === '--timeout') {
        $maxSeconds = $argv[++$i] ?? null;
        $maxSeconds = is_numeric($maxSeconds) ? (int)$maxSeconds : null;
        continue;
    }

    if ($arg === '--timeout-signal') {
        $signalValue = $argv[++$i] ?? null;
        $parsed = parse_timeout_signal($signalValue);
        if ($parsed === null) {
            fwrite(STDERR, "--timeout-signal requires a valid signal name or number\n");
            fwrite(STDERR, usage($argv[0]) . "\n");
            exit(1);
        }
        $timeoutSignalArg = $parsed['arg'];
        $timeoutSignal = $parsed['num'];
        continue;
    }

    if ($arg === '--jobs') {
        $jobs = $argv[++$i] ?? null;
        $jobs = is_numeric($jobs) ? (int)$jobs : null;
        continue;
    }

    if ($arg === '--interval') {
        $renderInterval = $argv[++$i] ?? null;
        $renderInterval = is_numeric($renderInterval) ? (float)$renderInterval : null;
        continue;
    }

    if ($arg === '--repro-tries') {
        $reproTries = $argv[++$i] ?? null;
        $reproTries = is_numeric($reproTries) ? (int)$reproTries : null;
        continue;
    }

    fwrite(STDERR, "Unknown option: {$arg}\n");
    fwrite(STDERR, usage($argv[0]) . "\n");
    exit(1);
}

if ($phpBin === null || $phpBin === '') {
    fwrite(STDERR, "Missing required --php-bin\n");
    fwrite(STDERR, usage($argv[0]) . "\n");
    exit(1);
}

if ($commandArgs === []) {
    fwrite(STDERR, "Missing command after --\n");
    fwrite(STDERR, usage($argv[0]) . "\n");
    exit(1);
}

$usesOps = false;
foreach ($commandArgs as $arg) {
    if (strpos($arg, '{ops}') !== false) {
        $usesOps = true;
        break;
    }
}

if ($usesOps && $ops === null) {
    fwrite(STDERR, "Missing required --ops for {ops} replacement\n");
    fwrite(STDERR, usage($argv[0]) . "\n");
    exit(1);
}

if ($reduce && !$usesOps) {
    fwrite(STDERR, "--reduce requires {ops} in the command arguments\n");
    fwrite(STDERR, usage($argv[0]) . "\n");
    exit(1);
}

if ($reduce && ($ops === null || $ops <= 0)) {
    fwrite(STDERR, "--reduce requires a positive --ops value\n");
    fwrite(STDERR, usage($argv[0]) . "\n");
    exit(1);
}

if ($maxSeconds !== null && $maxSeconds <= 0) {
    fwrite(STDERR, "--timeout requires a positive integer\n");
    fwrite(STDERR, usage($argv[0]) . "\n");
    exit(1);
}

if ($timeoutSignalArg !== null && $maxSeconds === null) {
    fwrite(STDERR, "--timeout-signal requires --timeout\n");
    fwrite(STDERR, usage($argv[0]) . "\n");
    exit(1);
}

if ($onlyCrashes && $timeoutSignal !== null && in_array($timeoutSignal, CRASH_SIGNALS, true)) {
    fwrite(STDERR, "you can't set the timeout signal to a crash signal and then ask for only crashes\n");
    exit(1);
}

if ($jobs === null || $jobs <= 0) {
    fwrite(STDERR, "--jobs requires a positive integer\n");
    fwrite(STDERR, usage($argv[0]) . "\n");
    exit(1);
}

if ($renderInterval === null || $renderInterval <= 0) {
    fwrite(STDERR, "--interval requires a positive number\n");
    fwrite(STDERR, usage($argv[0]) . "\n");
    exit(1);
}

if ($reproTries === null || $reproTries <= 0) {
    fwrite(STDERR, "--repro-tries requires a positive integer\n");
    fwrite(STDERR, usage($argv[0]) . "\n");
    exit(1);
}

$harnessMode = strtolower(trim($harnessMode));
if ($harnessMode === '') {
    $harnessMode = 'fuzz';
}
if (!in_array($harnessMode, ['fuzz', 'script'], true)) {
    fwrite(STDERR, "Invalid --mode: {$harnessMode} (use fuzz or script)\n");
    fwrite(STDERR, usage($argv[0]) . "\n");
    exit(1);
}

if ($harnessMode === 'script' && !should_generate_script($commandArgs)) {
    fwrite(STDERR, "--mode=script requires the command after -- to be bin/fuzzer\n");
    fwrite(STDERR, usage($argv[0]) . "\n");
    exit(1);
}

ensure_core_ulimit_unlimited();

$reproducersDir = __DIR__ . '/../reproducers';
if (!is_dir($reproducersDir)) {
    mkdir($reproducersDir, 0777, true);
}
$reproducerCounts = count_reproducer_dirs($reproducersDir);
$leaksDir = __DIR__ . '/../leaks';
if (!is_dir($leaksDir)) {
    mkdir($leaksDir, 0777, true);
}

$currentOps = $ops;
$stats = [
    'start_time' => microtime(true),
    'runs' => 0,
    'reproducers' => $reproducerCounts['total'],
    'reproducers_reproducing' => $reproducerCounts['reproducing'],
    'last_failure_time' => null,
    'last_failure_summary' => '',
    'reductions' => 0,
    'last_command' => '',
    'last_event' => '',
    'last_reproducer' => '',
    'active_jobs' => 0,
    'relay_memory' => null,
];

$jobCounter = 0;
$runningJobs = [];
$crashResult = null;
$crashJob = null;
$stopAfterCrash = false;
$leakResult = null;
$leakJob = null;
$stopAfterLeak = false;
$lastRenderTime = 0.0;

while (true) {
    $progress = false;

    while (!$stopAfterCrash && !$stopAfterLeak && count($runningJobs) < $jobs) {
        $jobCounter++;
        if ($harnessMode === 'script') {
            $job = create_script_job(
                $commandArgs,
                $currentOps,
                $phpBin,
                $phpIni,
                $phpArgs,
                $jobCounter,
                $maxSeconds,
                $timeoutSignalArg,
                $timeoutSignal
            );
        } else {
            $job = create_job(
                $commandArgs,
                $currentOps,
                $phpBin,
                $phpIni,
                $phpArgs,
                $jobCounter,
                $maxSeconds,
                $timeoutSignalArg,
                $timeoutSignal
            );
        }
        $runningJobs[$job['id']] = $job;
        $stats['last_command'] = $job['command_string'];
        $stats['last_event'] = "spawned job {$job['id']}";
        $progress = true;
    }

    $stats['active_jobs'] = count($runningJobs);

    foreach ($runningJobs as $jobId => &$job) {
        $result = poll_command($job, $timeoutSignal, $onlyCrashes);
        if ($result === null) {
            continue;
        }

        $progress = true;
        unset($runningJobs[$jobId]);
        $stats['runs']++;
        $stats['last_command'] = $job['command_string'];
        $stats['last_event'] = "job {$jobId} finished";

        if ($job['cancelled']) {
            cleanup_output_files($result);
            if ($harnessMode === 'script' && isset($job['script_dir'])) {
                remove_dir_recursive((string) $job['script_dir']);
            }
            continue;
        }

        $leakCount = null;
        if ($capturePhpLeaks) {
            $leakCount = parse_php_leak_count($result['stdout_path'], $result['stderr_path']);
        }

        if (
            $result['exit_code'] === 0
            && $result['signal'] === null
            && !$result['timed_out']
            && !$result['is_crash']
        ) {
            $memory = parse_relay_memory_from_output($result['stdout_path']);
            if ($memory !== null) {
                $stats['relay_memory'] = $memory;
            }
        }

        if ($result['is_crash'] && $crashResult === null) {
            $crashResult = $result;
            $crashJob = $job;
            $stats['last_failure_time'] = microtime(true);
            $stats['last_failure_summary'] = build_failure_summary($result);
            $stats['last_event'] = 'crash detected';
            $stopAfterCrash = true;

            foreach ($runningJobs as &$pendingJob) {
                cancel_command($pendingJob);
            }
        } elseif ($leakCount !== null && $leakResult === null && !$result['is_crash']) {
            $result['leak_count'] = $leakCount;
            $leakResult = $result;
            $leakJob = $job;
            $stats['last_failure_time'] = microtime(true);
            $stats['last_failure_summary'] = "LEAKS: {$leakCount}";
            $stats['last_event'] = 'leak detected';
            $stopAfterLeak = true;

            foreach ($runningJobs as &$pendingJob) {
                cancel_command($pendingJob);
            }
        } else {
            cleanup_output_files($result);
            if ($harnessMode === 'script' && isset($job['script_dir'])) {
                remove_dir_recursive((string) $job['script_dir']);
            }
        }

        $stats['active_jobs'] = count($runningJobs);
        maybe_render_screen(
            $stats,
            $currentOps,
            $stopAfterCrash ? 'reducing' : ($harnessMode === 'script' ? 'script' : 'fuzzing'),
            $renderInterval,
            $lastRenderTime,
            $result['is_crash'] || $leakCount !== null
        );
    }
    unset($job);

    maybe_render_screen(
        $stats,
        $currentOps,
        $stopAfterCrash ? 'reducing' : ($harnessMode === 'script' ? 'script' : 'fuzzing'),
        $renderInterval,
        $lastRenderTime
    );

    if ($crashResult !== null && $runningJobs === []) {
        $jobId = date('Ymd_His') . '_' . bin2hex(random_bytes(4));
        $jobDir = $reproducersDir . '/' . $jobId;
        mkdir($jobDir, 0777, true);

        $finalCommand = $crashJob['command_string'];
        $finalOps = $currentOps;
        $originalOps = $currentOps;
        $dynamicArgs = $crashJob['dynamic_args'];
        $finalPhpArgs = $crashJob['php_args'] ?? [];
        $finalGeneratorCommand = $crashJob['generator_command'] ?? null;

        if ($reduce && $currentOps !== null) {
            $stats['reductions']++;
            $stats['active_jobs'] = 1;
            if ($harnessMode === 'script') {
                $finalOps = reduce_ops_script(
                    $currentOps,
                    $dynamicArgs,
                    $phpBin,
                    $phpIni,
                    $finalPhpArgs,
                    $stats,
                    $jobDir,
                    $maxSeconds,
                    $timeoutSignalArg,
                    $timeoutSignal,
                    $onlyCrashes,
                    $renderInterval,
                    $lastRenderTime
                );
            } else {
                $finalOps = reduce_ops(
                    $currentOps,
                    $dynamicArgs,
                    $phpBin,
                    $phpIni,
                    $finalPhpArgs,
                    $stats,
                    $jobDir,
                    $maxSeconds,
                    $timeoutSignalArg,
                    $timeoutSignal,
                    $onlyCrashes,
                    $renderInterval,
                    $lastRenderTime
                );
                $reducedArgs = array_map(static fn(string $arg): string => apply_ops($arg, $finalOps), $dynamicArgs);
                $finalCommand = render_command(wrap_timeout_command(
                    build_php_command($phpBin, $phpIni, $finalPhpArgs, $reducedArgs),
                    $maxSeconds,
                    $timeoutSignalArg
                ));

                if ($finalCommand !== $crashJob['command_string']) {
                    file_put_contents($jobDir . '/command-original.txt', $crashJob['command_string'] . "\n");
                }
            }
        }

        $finalRunArgs = array_map(static fn(string $arg): string => apply_ops($arg, $finalOps), $dynamicArgs);
        if ($harnessMode === 'script') {
            $finalGeneratorCommand = render_command(build_php_command($phpBin, $phpIni, $finalPhpArgs, $finalRunArgs));
        }

        $outputFiles = move_output_files($crashResult, $jobDir);
        cleanup_output_files($crashResult);

        if ($harnessMode === 'script') {
            $shouldRegenerate = $reduce && $finalOps !== null && $finalOps !== $originalOps;
            if (!$shouldRegenerate && isset($crashJob['script_dir'])) {
                capture_script_artifacts((string) $crashJob['script_dir'], $jobDir);
            } else {
                generate_reproducer_script($jobDir, $phpBin, $phpIni, $finalPhpArgs, $finalRunArgs, $finalGeneratorCommand ?? $finalCommand);
            }
            $finalCommand = render_command(wrap_timeout_command(
                build_php_command($phpBin, $phpIni, $finalPhpArgs, [$jobDir . '/reproducer.php']),
                $maxSeconds,
                $timeoutSignalArg
            ));
            file_put_contents($jobDir . '/command.txt', $finalCommand . "\n");
            if ($finalGeneratorCommand !== null) {
                file_put_contents($jobDir . '/generator-command.txt', $finalGeneratorCommand . "\n");
                if ($reduce && $finalOps !== null && $finalOps !== $originalOps && isset($crashJob['generator_command'])) {
                    file_put_contents($jobDir . '/generator-command-original.txt', $crashJob['generator_command'] . "\n");
                }
            }
        } else {
            file_put_contents($jobDir . '/command.txt', $finalCommand . "\n");
            generate_reproducer_script($jobDir, $phpBin, $phpIni, $finalPhpArgs, $finalRunArgs, $finalCommand);
        }

        $signal = $crashResult['signal'];
        $exitCode = $crashResult['exit_code'];
        $pid = $crashResult['pid'];

        $signalLabel = $signal !== null ? signal_label($signal) : 'none';
        $signalDesc = $signal !== null ? signal_description($signal) : '';
        $exitName = !empty($crashResult['timed_out'])
            ? 'TIMEOUT'
            : ($signal !== null ? $signalLabel : "EXIT_{$exitCode}");

        $reportData = [
            'command' => $finalCommand,
            'exit_code' => $exitCode,
            'exit_name' => $exitName,
            'signal' => $signalLabel,
        ];
        if ($finalOps !== null) {
            $reportData['ops'] = $finalOps;
        }
        if ($signalDesc !== '') {
            $reportData['signal_desc'] = $signalDesc;
        }
        if (!empty($crashResult['timed_out'])) {
            $reportData['timed_out'] = true;
            if ($maxSeconds !== null) {
                $reportData['max_seconds'] = $maxSeconds;
            }
            if (!empty($crashResult['timeout_signal'])) {
                $reportData['timeout_signal'] = $crashResult['timeout_signal'];
            }
        }
        $reportData['pid'] = $pid ?? 'unknown';
        if (!empty($crashResult['core_files'])) {
            $reportData['core_files'] = array_map('basename', $crashResult['core_files']);
        }
        if ($outputFiles !== []) {
            $reportData['output_files'] = $outputFiles;
        }
        if ($harnessMode === 'script' && $finalGeneratorCommand !== null) {
            $reportData['generator_command'] = $finalGeneratorCommand;
        }

        $report = [];
        foreach ($reportData as $key => $value) {
            if (is_array($value)) {
                $value = implode(', ', $value);
            } elseif (is_bool($value)) {
                $value = $value ? 'yes' : 'no';
            }
            $report[] = "{$key}: {$value}";
        }

        file_put_contents($jobDir . '/report.txt', implode("\n", $report) . "\n");
        file_put_contents(
            $jobDir . '/report.json',
            json_encode($reportData, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES) . "\n"
        );
        $movedCores = move_core_dumps($crashResult['core_files'], $jobDir);
        generate_gdb_backtraces($movedCores, $jobDir, $phpBin);

        $reproducerScript = $jobDir . '/reproducer.php';
        $reproducerCrash = false;
        if (is_file($reproducerScript)) {
            $reproducerCommand = build_php_command($phpBin, $phpIni, $finalPhpArgs, [$reproducerScript]);
            for ($attempt = 1; $attempt <= $reproTries; $attempt++) {
                $stats['last_event'] = $reproTries > 1
                    ? "running reproducer ({$attempt}/{$reproTries})"
                    : 'running reproducer';
                $reproducerResult = run_command(
                    $reproducerCommand,
                    $phpBin,
                    $maxSeconds,
                    $timeoutSignalArg,
                    $timeoutSignal,
                    $onlyCrashes
                );
                $reproducerCrash = $reproducerResult['is_crash'];
                if (!empty($reproducerResult['core_files'])) {
                    $reproducerCores = move_core_dumps($reproducerResult['core_files'], $jobDir);
                    generate_gdb_backtraces($reproducerCores, $jobDir, $phpBin);
                }
                cleanup_output_files($reproducerResult);
                if ($reproducerCrash) {
                    break;
                }
            }
        }

        $finalJobDir = move_reproducer_dir($jobDir, $reproducersDir, $reproducerCrash);
        if ($harnessMode === 'script' && isset($crashJob['script_dir'])) {
            remove_dir_recursive((string) $crashJob['script_dir']);
        }

        $stats['reproducers']++;
        if ($reproducerCrash) {
            $stats['reproducers_reproducing']++;
        }
        $stats['last_event'] = "reproducer saved: {$finalJobDir}";
        $stats['last_reproducer'] = $finalJobDir;
        $stats['active_jobs'] = 0;
        maybe_render_screen(
            $stats,
            $currentOps,
            $reduce ? 'reducing' : ($harnessMode === 'script' ? 'script' : 'fuzzing'),
            $renderInterval,
            $lastRenderTime,
            true
        );

        if ($reduce && $finalOps !== null && $reproducerCrash) {
            $currentOps = $finalOps;
        }

        $crashResult = null;
        $crashJob = null;
        $stopAfterCrash = false;
        continue;
    }

    if ($leakResult !== null && $runningJobs === []) {
        $jobId = date('Ymd_His') . '_' . bin2hex(random_bytes(4));
        $jobDir = $leaksDir . '/' . $jobId;
        mkdir($jobDir, 0777, true);

        $finalCommand = $leakJob['command_string'];
        $finalOps = $currentOps;
        $dynamicArgs = $leakJob['dynamic_args'];
        $finalPhpArgs = $leakJob['php_args'] ?? [];
        $finalGeneratorCommand = $leakJob['generator_command'] ?? null;

        $finalRunArgs = array_map(static fn(string $arg): string => apply_ops($arg, $finalOps), $dynamicArgs);
        if ($harnessMode === 'script') {
            $finalGeneratorCommand = render_command(build_php_command($phpBin, $phpIni, $finalPhpArgs, $finalRunArgs));
        } else {
            file_put_contents($jobDir . '/command.txt', $finalCommand . "\n");
        }

        $outputFiles = move_output_files($leakResult, $jobDir);
        cleanup_output_files($leakResult);

        if ($harnessMode === 'script') {
            if (isset($leakJob['script_dir'])) {
                capture_script_artifacts((string) $leakJob['script_dir'], $jobDir);
            } else {
                generate_reproducer_script($jobDir, $phpBin, $phpIni, $finalPhpArgs, $finalRunArgs, $finalGeneratorCommand ?? $finalCommand);
            }
            $finalCommand = render_command(wrap_timeout_command(
                build_php_command($phpBin, $phpIni, $finalPhpArgs, [$jobDir . '/reproducer.php']),
                $maxSeconds,
                $timeoutSignalArg
            ));
            file_put_contents($jobDir . '/command.txt', $finalCommand . "\n");
            if ($finalGeneratorCommand !== null) {
                file_put_contents($jobDir . '/generator-command.txt', $finalGeneratorCommand . "\n");
            }
        } else {
            generate_reproducer_script($jobDir, $phpBin, $phpIni, $finalPhpArgs, $finalRunArgs, $finalCommand);
        }

        $signal = $leakResult['signal'];
        $exitCode = $leakResult['exit_code'];
        $pid = $leakResult['pid'];
        $leakCount = $leakResult['leak_count'] ?? null;

        $signalLabel = $signal !== null ? signal_label($signal) : 'none';
        $signalDesc = $signal !== null ? signal_description($signal) : '';
        $exitName = !empty($leakResult['timed_out'])
            ? 'TIMEOUT'
            : ($signal !== null ? $signalLabel : "EXIT_{$exitCode}");

        $reportData = [
            'command' => $finalCommand,
            'exit_code' => $exitCode,
            'exit_name' => $exitName,
            'signal' => $signalLabel,
        ];
        if ($finalOps !== null) {
            $reportData['ops'] = $finalOps;
        }
        if ($signalDesc !== '') {
            $reportData['signal_desc'] = $signalDesc;
        }
        if (!empty($leakResult['timed_out'])) {
            $reportData['timed_out'] = true;
            if ($maxSeconds !== null) {
                $reportData['max_seconds'] = $maxSeconds;
            }
            if (!empty($leakResult['timeout_signal'])) {
                $reportData['timeout_signal'] = $leakResult['timeout_signal'];
            }
        }
        $reportData['pid'] = $pid ?? 'unknown';
        if ($leakCount !== null) {
            $reportData['leak_count'] = $leakCount;
        }
        if (!empty($leakResult['core_files'])) {
            $reportData['core_files'] = array_map('basename', $leakResult['core_files']);
        }
        if ($outputFiles !== []) {
            $reportData['output_files'] = $outputFiles;
        }
        if ($harnessMode === 'script' && $finalGeneratorCommand !== null) {
            $reportData['generator_command'] = $finalGeneratorCommand;
        }

        $report = [];
        foreach ($reportData as $key => $value) {
            if (is_array($value)) {
                $value = implode(', ', $value);
            } elseif (is_bool($value)) {
                $value = $value ? 'yes' : 'no';
            }
            $report[] = "{$key}: {$value}";
        }

        file_put_contents($jobDir . '/report.txt', implode("\n", $report) . "\n");
        file_put_contents(
            $jobDir . '/report.json',
            json_encode($reportData, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES) . "\n"
        );
        $movedCores = move_core_dumps($leakResult['core_files'], $jobDir);
        generate_gdb_backtraces($movedCores, $jobDir, $phpBin);

        $reproducerScript = $jobDir . '/reproducer.php';
        $reproducerLeak = false;
        if (is_file($reproducerScript)) {
            $reproducerCommand = build_php_command($phpBin, $phpIni, $finalPhpArgs, [$reproducerScript]);
            for ($attempt = 1; $attempt <= $reproTries; $attempt++) {
                $stats['last_event'] = $reproTries > 1
                    ? "running leak reproducer ({$attempt}/{$reproTries})"
                    : 'running leak reproducer';
                $reproducerResult = run_command(
                    $reproducerCommand,
                    $phpBin,
                    $maxSeconds,
                    $timeoutSignalArg,
                    $timeoutSignal,
                    $onlyCrashes
                );
                $reproducerLeak = parse_php_leak_count(
                    $reproducerResult['stdout_path'],
                    $reproducerResult['stderr_path']
                ) !== null;
                if (!empty($reproducerResult['core_files'])) {
                    $reproducerCores = move_core_dumps($reproducerResult['core_files'], $jobDir);
                    generate_gdb_backtraces($reproducerCores, $jobDir, $phpBin);
                }
                cleanup_output_files($reproducerResult);
                if ($reproducerLeak) {
                    break;
                }
            }
        }

        $finalJobDir = move_reproducer_dir($jobDir, $leaksDir, $reproducerLeak);
        if ($harnessMode === 'script' && isset($leakJob['script_dir'])) {
            remove_dir_recursive((string) $leakJob['script_dir']);
        }

        $stats['last_event'] = "leak saved: {$finalJobDir}";
        $stats['last_reproducer'] = $finalJobDir;
        $stats['active_jobs'] = 0;
        maybe_render_screen(
            $stats,
            $currentOps,
            $reduce ? 'reducing' : ($harnessMode === 'script' ? 'script' : 'fuzzing'),
            $renderInterval,
            $lastRenderTime,
            true
        );

        $leakResult = null;
        $leakJob = null;
        $stopAfterLeak = false;
        continue;
    }

    if (!$progress) {
        usleep(10000);
    }
}

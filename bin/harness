#!/usr/bin/env php
<?php

declare(strict_types=1);

const CRASH_SIGNALS = [
    SIGSEGV,
    SIGBUS,
    SIGILL,
    SIGABRT,
    SIGFPE,
    SIGTRAP,
];

const SIGNAL_LABELS = [
    SIGSEGV => 'SIGSEGV',
    SIGBUS => 'SIGBUS',
    SIGILL => 'SIGILL',
    SIGABRT => 'SIGABRT',
    SIGFPE => 'SIGFPE',
    SIGTRAP => 'SIGTRAP',
];

function usage(string $script): string
{
    return <<<USAGE
Usage:
  {$script} --php-bin /path/to/php [--php-ini /path/to/php.ini] [--ops N] [--reduce] [--max-seconds N] [--jobs N] [--interval SECONDS] -- <command...>

Dynamic replacements in command arguments:
  {range}            -> random integer
  {range(lo,hi)}     -> random integer between lo and hi (inclusive)
  {hrtime}           -> hrtime(true)
  {ops}              -> value provided via --ops
USAGE;
}

function render_command(array $command): string
{
    return implode(' ', array_map('escapeshellarg', $command));
}

function signal_label(int $signal): string
{
    return SIGNAL_LABELS[$signal] ?? "SIG{$signal}";
}

function signal_description(int $signal): string
{
    if (function_exists('pcntl_strsignal')) {
        $desc = pcntl_strsignal($signal);
        if (is_string($desc) && $desc !== '') {
            return $desc;
        }
    }

    return '';
}

function replace_dynamic(string $arg): string
{
    $arg = preg_replace_callback('/\{range\((\-?\d+)\s*,\s*(\-?\d+)\)\}/', static function (array $matches): string {
        $lo = (int)$matches[1];
        $hi = (int)$matches[2];
        if ($lo > $hi) {
            [$lo, $hi] = [$hi, $lo];
        }

        return (string)random_int($lo, $hi);
    }, $arg);

    $arg = preg_replace_callback('/\{range\}/', static function (): string {
        return (string)random_int(0, PHP_INT_MAX);
    }, $arg);

    $arg = preg_replace_callback('/\{hrtime\}/', static function (): string {
        return (string)hrtime(true);
    }, $arg);

    return $arg;
}

function apply_ops(string $arg, ?int $ops): string
{
    if ($ops === null) {
        return $arg;
    }

    return str_replace('{ops}', (string)$ops, $arg);
}

function format_duration(int $seconds): string
{
    $days = intdiv($seconds, 86400);
    $seconds -= $days * 86400;
    $hours = intdiv($seconds, 3600);
    $seconds -= $hours * 3600;
    $minutes = intdiv($seconds, 60);
    $seconds -= $minutes * 60;

    if ($days > 0) {
        return sprintf('%dd %02d:%02d:%02d', $days, $hours, $minutes, $seconds);
    }

    return sprintf('%02d:%02d:%02d', $hours, $minutes, $seconds);
}

function terminal_width(): int
{
    $columns = getenv('COLUMNS');
    if (is_string($columns) && ctype_digit($columns)) {
        return max(60, (int)$columns);
    }

    return 80;
}

function truncate_text(string $text, int $width): string
{
    if ($width <= 0) {
        return '';
    }

    if (strlen($text) <= $width) {
        return $text;
    }

    if ($width <= 3) {
        return substr($text, 0, $width);
    }

    return substr($text, 0, $width - 3) . '...';
}

function pad_line(string $text, int $width): string
{
    $text = truncate_text($text, $width);
    return str_pad($text, $width);
}

function two_column(string $left, string $right, int $width, int $gap = 3): string
{
    $gap = max(1, $gap);
    $leftWidth = intdiv($width - $gap, 2);
    $rightWidth = $width - $gap - $leftWidth;

    $left = str_pad(truncate_text($left, $leftWidth), $leftWidth);
    $right = str_pad(truncate_text($right, $rightWidth), $rightWidth);

    return $left . str_repeat(' ', $gap) . $right;
}

function render_screen(array $stats, ?int $currentOps, string $mode): void
{
    $width = terminal_width();
    $now = microtime(true);
    $elapsed = format_duration((int)($now - $stats['start_time']));
    $sinceFailure = $stats['last_failure_time'] !== null
        ? format_duration((int)($now - $stats['last_failure_time']))
        : 'never';

    $lines = [];
    $lines[] = str_repeat('=', $width);
    $title = 'relay-table-fuzzer harness';
    $lines[] = pad_line(str_pad($title, $width, ' ', STR_PAD_BOTH), $width);
    $lines[] = str_repeat('-', $width);
    $activeJobs = $stats['active_jobs'] ?? 1;
    $lines[] = two_column("Elapsed: {$elapsed}", 'Runs: ' . number_format($stats['runs']), $width);
    $lines[] = two_column("Jobs: {$activeJobs}", 'Reproducers: ' . number_format($stats['reproducers']), $width);
    $lines[] = two_column("Last failure: {$sinceFailure}", 'Reductions: ' . number_format($stats['reductions']), $width);
    $opsLabel = $currentOps !== null ? (string)$currentOps : 'n/a';
    $lines[] = two_column("Ops: {$opsLabel}", "Mode: {$mode}", $width);
    $lastFailure = $stats['last_failure_summary'] !== '' ? $stats['last_failure_summary'] : 'none';
    $event = $stats['last_event'] !== '' ? $stats['last_event'] : 'none';
    $lines[] = two_column("Last crash: {$lastFailure}", "Event: {$event}", $width);
    $lastRepro = $stats['last_reproducer'] !== '' ? $stats['last_reproducer'] : 'n/a';
    $lines[] = pad_line("Last reproducer: {$lastRepro}", $width);
    $lines[] = str_repeat('-', $width);
    $command = $stats['last_command'] ?? '';
    $lines[] = pad_line("Command: {$command}", $width);
    $lines[] = str_repeat('=', $width);

    fwrite(STDOUT, "\033[2J\033[H" . implode("\n", $lines) . "\n");
    fflush(STDOUT);
}

function maybe_render_screen(
    array $stats,
    ?int $currentOps,
    string $mode,
    float $interval,
    float &$lastRenderTime,
    bool $force = false
): void {
    $now = microtime(true);
    if (!$force && $interval > 0 && ($now - $lastRenderTime) < $interval) {
        return;
    }

    $lastRenderTime = $now;
    render_screen($stats, $currentOps, $mode);
}

function find_core_dumps(string $phpBin, ?int $pid): array
{
    if ($pid === null) {
        return [];
    }

    $binary = basename($phpBin);
    $pattern = "/tmp/core.{$binary}.{$pid}.*";
    $cores = glob($pattern);

    return $cores !== false ? $cores : [];
}

function run_command(array $fullCommand, string $phpBin, ?int $maxSeconds): array
{
    $stdoutPath = tempnam(sys_get_temp_dir(), 'relay-harness-out-');
    $stderrPath = tempnam(sys_get_temp_dir(), 'relay-harness-err-');
    $descriptorSpec = [
        0 => ['file', 'php://stdin', 'r'],
        1 => ['file', $stdoutPath !== false ? $stdoutPath : 'php://stdout', 'w'],
        2 => ['file', $stderrPath !== false ? $stderrPath : 'php://stderr', 'w'],
    ];

    $process = proc_open($fullCommand, $descriptorSpec, $pipes);
    if (!is_resource($process)) {
        fwrite(STDERR, "Failed to start process\n");
        exit(1);
    }

    $status = proc_get_status($process);
    $pid = $status['pid'] ?? null;
    $start = microtime(true);
    $timedOut = false;

    while ($status['running']) {
        usleep(10000);
        if ($maxSeconds !== null && (microtime(true) - $start) >= $maxSeconds) {
            $timedOut = true;
            proc_terminate($process);
            usleep(100000);
            $status = proc_get_status($process);
            if ($status['running']) {
                proc_terminate($process, SIGKILL);
            }
            break;
        }
        $status = proc_get_status($process);
    }

    if ($status['running']) {
        for ($i = 0; $i < 50; $i++) {
            usleep(100000);
            $status = proc_get_status($process);
            if (!$status['running']) {
                break;
            }
        }
    }

    $exitCode = proc_close($process);

    $signal = null;
    if (($status['signaled'] ?? false) && isset($status['termsig'])) {
        $signal = (int)$status['termsig'];
    } elseif ($exitCode !== 0 && $exitCode > 128) {
        $signal = $exitCode - 128;
    }

    $coreFiles = find_core_dumps($phpBin, $pid);
    $isCrash = $timedOut || (($signal !== null && in_array($signal, CRASH_SIGNALS, true)) || $coreFiles !== []);

    return [
        'exit_code' => $exitCode,
        'signal' => $signal,
        'pid' => $pid,
        'timed_out' => $timedOut,
        'is_crash' => $isCrash,
        'core_files' => $coreFiles,
        'stdout_path' => $stdoutPath !== false ? $stdoutPath : null,
        'stderr_path' => $stderrPath !== false ? $stderrPath : null,
    ];
}

function start_command(array $fullCommand, string $phpBin): array
{
    $stdoutPath = tempnam(sys_get_temp_dir(), 'relay-harness-out-');
    $stderrPath = tempnam(sys_get_temp_dir(), 'relay-harness-err-');
    $descriptorSpec = [
        0 => ['file', 'php://stdin', 'r'],
        1 => ['file', $stdoutPath !== false ? $stdoutPath : 'php://stdout', 'w'],
        2 => ['file', $stderrPath !== false ? $stderrPath : 'php://stderr', 'w'],
    ];

    $process = proc_open($fullCommand, $descriptorSpec, $pipes);
    if (!is_resource($process)) {
        fwrite(STDERR, "Failed to start process\n");
        exit(1);
    }

    $status = proc_get_status($process);

    return [
        'process' => $process,
        'pid' => $status['pid'] ?? null,
        'start_time' => microtime(true),
        'php_bin' => $phpBin,
        'stdout_path' => $stdoutPath !== false ? $stdoutPath : null,
        'stderr_path' => $stderrPath !== false ? $stderrPath : null,
        'timed_out' => false,
        'cancelled' => false,
    ];
}

function finalize_command(array $job, array $status): array
{
    $exitCode = proc_close($job['process']);
    $signal = null;
    if (($status['signaled'] ?? false) && isset($status['termsig'])) {
        $signal = (int)$status['termsig'];
    } elseif ($exitCode !== 0 && $exitCode > 128) {
        $signal = $exitCode - 128;
    }

    $coreFiles = find_core_dumps($job['php_bin'], $job['pid']);
    $isCrash = $job['timed_out'] || (($signal !== null && in_array($signal, CRASH_SIGNALS, true)) || $coreFiles !== []);

    return [
        'exit_code' => $exitCode,
        'signal' => $signal,
        'pid' => $job['pid'],
        'timed_out' => $job['timed_out'],
        'is_crash' => $isCrash,
        'core_files' => $coreFiles,
        'stdout_path' => $job['stdout_path'],
        'stderr_path' => $job['stderr_path'],
    ];
}

function poll_command(array &$job, ?int $maxSeconds): ?array
{
    $status = proc_get_status($job['process']);
    if ($status['running']) {
        if (!empty($job['cancelled'])) {
            proc_terminate($job['process']);
            $cancelAt = $job['cancel_requested_at'] ?? $job['start_time'];
            if ((microtime(true) - $cancelAt) >= 1.0) {
                proc_terminate($job['process'], SIGKILL);
            }
            return null;
        }

        if ($maxSeconds !== null && (microtime(true) - $job['start_time']) >= $maxSeconds) {
            $job['timed_out'] = true;
            proc_terminate($job['process']);
            usleep(100000);
            $status = proc_get_status($job['process']);
            if ($status['running']) {
                proc_terminate($job['process'], SIGKILL);
            }
        } else {
            return null;
        }
    }

    if ($status['running']) {
        for ($i = 0; $i < 10; $i++) {
            usleep(100000);
            $status = proc_get_status($job['process']);
            if (!$status['running']) {
                break;
            }
        }
    }

    return finalize_command($job, $status);
}

function cancel_command(array &$job): void
{
    if ($job['cancelled']) {
        return;
    }

    $job['cancelled'] = true;
    $job['cancel_requested_at'] = microtime(true);
    proc_terminate($job['process']);
}

function create_job(
    array $commandArgs,
    ?int $currentOps,
    string $phpBin,
    ?string $phpIni,
    int $jobId
): array {
    $dynamicArgs = array_map('replace_dynamic', $commandArgs);
    $runArgs = array_map(static fn(string $arg): string => apply_ops($arg, $currentOps), $dynamicArgs);
    $fullCommand = array_merge([$phpBin], $phpIni !== null ? ['-c', $phpIni] : [], $runArgs);

    $job = start_command($fullCommand, $phpBin);
    $job['id'] = $jobId;
    $job['dynamic_args'] = $dynamicArgs;
    $job['full_command'] = $fullCommand;
    $job['command_string'] = render_command($fullCommand);
    $job['ops'] = $currentOps;

    return $job;
}

function reduce_ops(
    int $maxOps,
    array $dynamicArgs,
    string $phpBin,
    ?string $phpIni,
    array &$stats,
    string $jobDir,
    ?int $maxSeconds,
    float $renderInterval,
    float &$lastRenderTime
): int {
    $low = 1;
    $high = $maxOps;

    while ($low < $high) {
        $mid = intdiv($low + $high, 2);
        $runArgs = array_map(static fn(string $arg): string => apply_ops($arg, $mid), $dynamicArgs);
        $fullCommand = array_merge([$phpBin], $phpIni !== null ? ['-c', $phpIni] : [], $runArgs);
        $commandString = render_command($fullCommand);

        $result = run_command($fullCommand, $phpBin, $maxSeconds);
        $stats['runs']++;
        $stats['last_command'] = $commandString;
        $stats['last_event'] = "reducing ops: {$mid}";
        if ($result['is_crash']) {
            $stats['last_failure_time'] = microtime(true);
            $stats['last_failure_summary'] = build_failure_summary($result);
            $stats['last_event'] = "reducer crash at ops {$mid}";
            move_core_dumps($result['core_files'], $jobDir);
        }
        cleanup_output_files($result);
        maybe_render_screen($stats, $mid, 'reducing', $renderInterval, $lastRenderTime, $result['is_crash']);
        if ($result['is_crash']) {
            $high = $mid;
            continue;
        }

        $low = $mid + 1;
    }

    return $low;
}

function move_core_dumps(array $coreFiles, string $destinationDir): void
{
    foreach ($coreFiles as $coreFile) {
        $target = $destinationDir . '/' . basename($coreFile);
        if (@rename($coreFile, $target)) {
            continue;
        }

        if (@copy($coreFile, $target)) {
            @unlink($coreFile);
        }
    }
}

function cleanup_output_files(array $result): void
{
    foreach (['stdout_path', 'stderr_path'] as $key) {
        $path = $result[$key] ?? null;
        if (is_string($path) && $path !== '' && file_exists($path)) {
            @unlink($path);
        }
    }
}

function move_output_files(array $result, string $destinationDir): array
{
    $moved = [];
    $mapping = [
        'stdout_path' => 'stdout.log',
        'stderr_path' => 'stderr.log',
    ];

    foreach ($mapping as $key => $targetName) {
        $path = $result[$key] ?? null;
        if (!is_string($path) || $path === '' || !file_exists($path)) {
            continue;
        }

        $target = $destinationDir . '/' . $targetName;
        if (file_exists($target)) {
            @unlink($target);
        }
        if (@rename($path, $target)) {
            $moved[] = $targetName;
            continue;
        }

        if (@copy($path, $target)) {
            @unlink($path);
            $moved[] = $targetName;
        }
    }

    return $moved;
}

function build_failure_summary(array $result): string
{
    if (!empty($result['timed_out'])) {
        return 'TIMEOUT';
    }

    if (!empty($result['core_files'])) {
        $core = basename($result['core_files'][0]);
        return "core {$core}";
    }

    if ($result['signal'] !== null) {
        return signal_label($result['signal']);
    }

    return 'EXIT_' . $result['exit_code'];
}

$argv = $_SERVER['argv'];
$argc = $_SERVER['argc'];

$phpBin = null;
$phpIni = null;
$ops = null;
$reduce = false;
$maxSeconds = null;
$jobs = 1;
$renderInterval = 1.0;
$commandArgs = [];

for ($i = 1; $i < $argc; $i++) {
    $arg = $argv[$i];
    if ($arg === '--') {
        $commandArgs = array_slice($argv, $i + 1);
        break;
    }

    if ($arg === '--help' || $arg === '-h') {
        fwrite(STDOUT, usage($argv[0]) . "\n");
        exit(0);
    }

    if ($arg === '--php-bin') {
        $phpBin = $argv[++$i] ?? null;
        continue;
    }

    if ($arg === '--php-ini') {
        $phpIni = $argv[++$i] ?? null;
        continue;
    }

    if ($arg === '--ops') {
        $ops = $argv[++$i] ?? null;
        $ops = is_numeric($ops) ? (int)$ops : null;
        continue;
    }

    if ($arg === '--reduce') {
        $reduce = true;
        continue;
    }

    if ($arg === '--max-seconds') {
        $maxSeconds = $argv[++$i] ?? null;
        $maxSeconds = is_numeric($maxSeconds) ? (int)$maxSeconds : null;
        continue;
    }

    if ($arg === '--jobs') {
        $jobs = $argv[++$i] ?? null;
        $jobs = is_numeric($jobs) ? (int)$jobs : null;
        continue;
    }

    if ($arg === '--interval') {
        $renderInterval = $argv[++$i] ?? null;
        $renderInterval = is_numeric($renderInterval) ? (float)$renderInterval : null;
        continue;
    }

    fwrite(STDERR, "Unknown option: {$arg}\n");
    fwrite(STDERR, usage($argv[0]) . "\n");
    exit(1);
}

if ($phpBin === null || $phpBin === '') {
    fwrite(STDERR, "Missing required --php-bin\n");
    fwrite(STDERR, usage($argv[0]) . "\n");
    exit(1);
}

if ($commandArgs === []) {
    fwrite(STDERR, "Missing command after --\n");
    fwrite(STDERR, usage($argv[0]) . "\n");
    exit(1);
}

$usesOps = false;
foreach ($commandArgs as $arg) {
    if (strpos($arg, '{ops}') !== false) {
        $usesOps = true;
        break;
    }
}

if ($usesOps && $ops === null) {
    fwrite(STDERR, "Missing required --ops for {ops} replacement\n");
    fwrite(STDERR, usage($argv[0]) . "\n");
    exit(1);
}

if ($reduce && !$usesOps) {
    fwrite(STDERR, "--reduce requires {ops} in the command arguments\n");
    fwrite(STDERR, usage($argv[0]) . "\n");
    exit(1);
}

if ($reduce && ($ops === null || $ops <= 0)) {
    fwrite(STDERR, "--reduce requires a positive --ops value\n");
    fwrite(STDERR, usage($argv[0]) . "\n");
    exit(1);
}

if ($maxSeconds !== null && $maxSeconds <= 0) {
    fwrite(STDERR, "--max-seconds requires a positive integer\n");
    fwrite(STDERR, usage($argv[0]) . "\n");
    exit(1);
}

if ($jobs === null || $jobs <= 0) {
    fwrite(STDERR, "--jobs requires a positive integer\n");
    fwrite(STDERR, usage($argv[0]) . "\n");
    exit(1);
}

if ($renderInterval === null || $renderInterval <= 0) {
    fwrite(STDERR, "--interval requires a positive number\n");
    fwrite(STDERR, usage($argv[0]) . "\n");
    exit(1);
}

$reproducersDir = __DIR__ . '/../reproducers';
if (!is_dir($reproducersDir)) {
    mkdir($reproducersDir, 0777, true);
}

$currentOps = $ops;
$stats = [
    'start_time' => microtime(true),
    'runs' => 0,
    'reproducers' => 0,
    'last_failure_time' => null,
    'last_failure_summary' => '',
    'reductions' => 0,
    'last_command' => '',
    'last_event' => '',
    'last_reproducer' => '',
    'active_jobs' => 0,
];

$jobCounter = 0;
$runningJobs = [];
$crashResult = null;
$crashJob = null;
$stopAfterCrash = false;
$lastRenderTime = 0.0;

while (true) {
    $progress = false;

    while (!$stopAfterCrash && count($runningJobs) < $jobs) {
        $jobCounter++;
        $job = create_job($commandArgs, $currentOps, $phpBin, $phpIni, $jobCounter);
        $runningJobs[$job['id']] = $job;
        $stats['last_command'] = $job['command_string'];
        $stats['last_event'] = "spawned job {$job['id']}";
        $progress = true;
    }

    $stats['active_jobs'] = count($runningJobs);

    foreach ($runningJobs as $jobId => &$job) {
        $result = poll_command($job, $maxSeconds);
        if ($result === null) {
            continue;
        }

        $progress = true;
        unset($runningJobs[$jobId]);
        $stats['runs']++;
        $stats['last_command'] = $job['command_string'];
        $stats['last_event'] = "job {$jobId} finished";

        if ($job['cancelled']) {
            cleanup_output_files($result);
            continue;
        }

        if ($result['is_crash'] && $crashResult === null) {
            $crashResult = $result;
            $crashJob = $job;
            $stats['last_failure_time'] = microtime(true);
            $stats['last_failure_summary'] = build_failure_summary($result);
            $stats['last_event'] = 'crash detected';
            $stopAfterCrash = true;

            foreach ($runningJobs as &$pendingJob) {
                cancel_command($pendingJob);
            }
        } else {
            cleanup_output_files($result);
        }

        $stats['active_jobs'] = count($runningJobs);
        maybe_render_screen(
            $stats,
            $currentOps,
            $stopAfterCrash ? 'reducing' : 'fuzzing',
            $renderInterval,
            $lastRenderTime,
            $result['is_crash']
        );
    }
    unset($job);

    maybe_render_screen(
        $stats,
        $currentOps,
        $stopAfterCrash ? 'reducing' : 'fuzzing',
        $renderInterval,
        $lastRenderTime
    );

    if ($crashResult !== null && $runningJobs === []) {
        $jobId = date('Ymd_His') . '_' . bin2hex(random_bytes(4));
        $jobDir = $reproducersDir . '/' . $jobId;
        mkdir($jobDir, 0777, true);

        $finalCommand = $crashJob['command_string'];
        $finalOps = $currentOps;
        $dynamicArgs = $crashJob['dynamic_args'];

        if ($reduce && $currentOps !== null) {
            $stats['reductions']++;
            $stats['active_jobs'] = 1;
            $finalOps = reduce_ops(
                $currentOps,
                $dynamicArgs,
                $phpBin,
                $phpIni,
                $stats,
                $jobDir,
                $maxSeconds,
                $renderInterval,
                $lastRenderTime
            );
            $reducedArgs = array_map(static fn(string $arg): string => apply_ops($arg, $finalOps), $dynamicArgs);
            $finalCommand = render_command(array_merge([$phpBin], $phpIni !== null ? ['-c', $phpIni] : [], $reducedArgs));

            if ($finalCommand !== $crashJob['command_string']) {
                file_put_contents($jobDir . '/command-original.txt', $crashJob['command_string'] . "\n");
            }
        }

        file_put_contents($jobDir . '/command.txt', $finalCommand . "\n");

        $outputFiles = move_output_files($crashResult, $jobDir);
        cleanup_output_files($crashResult);

        $signal = $crashResult['signal'];
        $exitCode = $crashResult['exit_code'];
        $pid = $crashResult['pid'];

        $signalLabel = $signal !== null ? signal_label($signal) : 'none';
        $signalDesc = $signal !== null ? signal_description($signal) : '';
        $exitName = !empty($crashResult['timed_out'])
            ? 'TIMEOUT'
            : ($signal !== null ? $signalLabel : "EXIT_{$exitCode}");

        $reportData = [
            'command' => $finalCommand,
            'exit_code' => $exitCode,
            'exit_name' => $exitName,
            'signal' => $signalLabel,
        ];
        if ($finalOps !== null) {
            $reportData['ops'] = $finalOps;
        }
        if ($signalDesc !== '') {
            $reportData['signal_desc'] = $signalDesc;
        }
        if (!empty($crashResult['timed_out'])) {
            $reportData['timed_out'] = true;
            if ($maxSeconds !== null) {
                $reportData['max_seconds'] = $maxSeconds;
            }
        }
        $reportData['pid'] = $pid ?? 'unknown';
        if (!empty($crashResult['core_files'])) {
            $reportData['core_files'] = array_map('basename', $crashResult['core_files']);
        }
        if ($outputFiles !== []) {
            $reportData['output_files'] = $outputFiles;
        }

        $report = [];
        foreach ($reportData as $key => $value) {
            if (is_array($value)) {
                $value = implode(', ', $value);
            } elseif (is_bool($value)) {
                $value = $value ? 'yes' : 'no';
            }
            $report[] = "{$key}: {$value}";
        }

        file_put_contents($jobDir . '/report.txt', implode("\n", $report) . "\n");
        file_put_contents(
            $jobDir . '/report.json',
            json_encode($reportData, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES) . "\n"
        );

        move_core_dumps($crashResult['core_files'], $jobDir);

        $stats['reproducers']++;
        $stats['last_event'] = "reproducer saved: {$jobDir}";
        $stats['last_reproducer'] = $jobDir;
        $stats['active_jobs'] = 0;
        maybe_render_screen(
            $stats,
            $currentOps,
            $reduce ? 'reducing' : 'fuzzing',
            $renderInterval,
            $lastRenderTime,
            true
        );

        if ($reduce && $finalOps !== null) {
            $currentOps = $finalOps;
            $crashResult = null;
            $crashJob = null;
            $stopAfterCrash = false;
            continue;
        }

        exit(1);
    }

    if (!$progress) {
        usleep(10000);
    }
}

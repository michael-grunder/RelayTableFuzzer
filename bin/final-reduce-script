#!/usr/bin/env php
<?php

declare(strict_types=1);

function usage(): string
{
    return <<<TEXT
Usage:
  bin/final-reduce-script [options] reproducer.php [php-arg ...]

Options:
  --php-bin PATH       Path to PHP binary (default: current PHP)
  --php-ini PATH       Path to php.ini (optional)
  --max-runs N         Number of attempts per candidate (default: 1)
  --timeout N          Kill runs that exceed N seconds
  --valgrind[=PATH]    Run under valgrind (default binary: valgrind)
  --help               Show this help

Notes:
  - Any single-dash arg (for example -drelay.maxmemory=12345) is forwarded to PHP.
  - You can also pass "-d value" and both parts will be forwarded.

Example:
  bin/final-reduce-script --php-bin ./php85d --php-ini relay.ini --max-runs 10 --timeout 10 \
    -drelay.maxmemory=12345 reproducers/reproducing/.../reproducer.php

TEXT;
}

function fail(string $message): never
{
    fwrite(STDERR, $message . "\n");
    exit(1);
}

function parse_args(array $argv): array
{
    $args = $argv;
    array_shift($args);

    $phpBin = PHP_BINARY;
    $phpIni = null;
    $maxRuns = 1;
    $timeoutSeconds = null;
    $valgrindBin = null;
    $phpArgs = [];
    $scriptPath = null;

    for ($i = 0, $count = count($args); $i < $count; $i++) {
        $arg = $args[$i];

        if ($arg === '--help') {
            fwrite(STDOUT, usage());
            exit(0);
        }

        if (str_starts_with($arg, '--php-bin=')) {
            $phpBin = substr($arg, strlen('--php-bin='));
            continue;
        }
        if ($arg === '--php-bin') {
            $i++;
            if (!isset($args[$i])) {
                fail("Missing value for --php-bin");
            }
            $phpBin = $args[$i];
            continue;
        }

        if (str_starts_with($arg, '--php-ini=')) {
            $phpIni = substr($arg, strlen('--php-ini='));
            continue;
        }
        if ($arg === '--php-ini' || $arg === '--php-inii') {
            $i++;
            if (!isset($args[$i])) {
                fail("Missing value for {$arg}");
            }
            $phpIni = $args[$i];
            continue;
        }

        if (str_starts_with($arg, '--max-runs=')) {
            $maxRuns = parse_max_runs(substr($arg, strlen('--max-runs=')));
            continue;
        }
        if ($arg === '--max-runs') {
            $i++;
            if (!isset($args[$i])) {
                fail("Missing value for --max-runs");
            }
            $maxRuns = parse_max_runs($args[$i]);
            continue;
        }

        if (str_starts_with($arg, '--timeout=')) {
            $timeoutSeconds = parse_timeout_seconds(substr($arg, strlen('--timeout=')));
            continue;
        }
        if ($arg === '--timeout') {
            $i++;
            if (!isset($args[$i])) {
                fail("Missing value for --timeout");
            }
            $timeoutSeconds = parse_timeout_seconds($args[$i]);
            continue;
        }

        if ($arg === '--valgrind') {
            $valgrindBin = 'valgrind';
            continue;
        }
        if (str_starts_with($arg, '--valgrind=')) {
            $value = substr($arg, strlen('--valgrind='));
            if ($value === '') {
                fail('--valgrind requires a binary path or name');
            }
            $valgrindBin = $value;
            continue;
        }

        if (str_starts_with($arg, '--')) {
            fail("Unknown option: {$arg}");
        }

        if ($arg === '-d') {
            $phpArgs[] = $arg;
            $i++;
            if (!isset($args[$i])) {
                fail('Missing value for -d');
            }
            $phpArgs[] = $args[$i];
            continue;
        }

        if ($arg !== '' && $arg[0] === '-') {
            $phpArgs[] = $arg;
            continue;
        }

        if ($scriptPath !== null) {
            fail('Only one script path is supported.');
        }

        $scriptPath = $arg;
    }

    if ($scriptPath === null) {
        fail(usage());
    }

    return [
        'php_bin' => $phpBin,
        'php_ini' => $phpIni,
        'max_runs' => $maxRuns,
        'timeout_seconds' => $timeoutSeconds,
        'valgrind_bin' => $valgrindBin,
        'php_args' => $phpArgs,
        'script_path' => $scriptPath,
    ];
}

function parse_max_runs(string $raw): int
{
    if ($raw === '' || preg_match('/^\d+$/', $raw) !== 1) {
        fail("Invalid --max-runs value: {$raw}");
    }

    $maxRuns = (int) $raw;
    if ($maxRuns < 1) {
        fail('--max-runs must be >= 1');
    }

    return $maxRuns;
}

function parse_timeout_seconds(string $raw): int
{
    if ($raw === '' || preg_match('/^\d+$/', $raw) !== 1) {
        fail("Invalid --timeout value: {$raw}");
    }

    $timeout = (int) $raw;
    if ($timeout < 1) {
        fail('--timeout must be >= 1');
    }

    return $timeout;
}

function resolve_executable_path(string $binary): string
{
    if ($binary === '') {
        return $binary;
    }
    if (str_contains($binary, '/')) {
        $real = realpath($binary);
        return $real !== false ? $real : $binary;
    }

    $path = getenv('PATH');
    if (!is_string($path) || $path === '') {
        return $binary;
    }

    foreach (explode(PATH_SEPARATOR, $path) as $dir) {
        if ($dir === '') {
            continue;
        }
        $candidate = rtrim($dir, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR . $binary;
        if (is_file($candidate) && is_executable($candidate)) {
            return $candidate;
        }
    }

    return $binary;
}

function create_temp_log(string $prefix): ?string
{
    $path = tempnam(sys_get_temp_dir(), $prefix);
    return $path !== false ? $path : null;
}

function parse_valgrind_error_count(?string $path): ?int
{
    if (!is_string($path) || $path === '' || !is_file($path)) {
        return null;
    }

    $lines = @file($path, FILE_IGNORE_NEW_LINES);
    if ($lines === false) {
        return null;
    }

    for ($i = count($lines) - 1; $i >= 0; $i--) {
        $line = trim($lines[$i]);
        if ($line === '') {
            continue;
        }
        if (preg_match('/ERROR\s+SUMMARY:\s*(\d+)\s+errors/i', $line, $matches) === 1) {
            return (int) $matches[1];
        }
    }

    return null;
}

function comment_out_line(string $line): string
{
    $lineBreak = '';
    $content = $line;
    if (str_ends_with($line, "\r\n")) {
        $lineBreak = "\r\n";
        $content = substr($line, 0, -2);
    } elseif (str_ends_with($line, "\n")) {
        $lineBreak = "\n";
        $content = substr($line, 0, -1);
    }

    $commented = preg_replace('/^(\s*)/', '$1// ', $content, 1);
    if ($commented === null) {
        $commented = '// ' . $content;
    }

    return $commented . $lineBreak;
}

function find_statement_end(array $lines, int $start): int
{
    $inSingle = false;
    $inDouble = false;
    $escape = false;
    $parenDepth = 0;
    $bracketDepth = 0;
    $braceDepth = 0;

    for ($idx = $start, $count = count($lines); $idx < $count; $idx++) {
        $line = $lines[$idx];
        $lineLen = strlen($line);

        for ($pos = 0; $pos < $lineLen; $pos++) {
            $ch = $line[$pos];

            if ($inSingle || $inDouble) {
                if ($escape) {
                    $escape = false;
                    continue;
                }
                if ($ch === '\\') {
                    $escape = true;
                    continue;
                }
                if ($inSingle && $ch === "'") {
                    $inSingle = false;
                    continue;
                }
                if ($inDouble && $ch === '"') {
                    $inDouble = false;
                    continue;
                }

                continue;
            }

            if ($ch === "'") {
                $inSingle = true;
                continue;
            }
            if ($ch === '"') {
                $inDouble = true;
                continue;
            }

            if ($ch === '(') {
                $parenDepth++;
                continue;
            }
            if ($ch === ')') {
                $parenDepth = max(0, $parenDepth - 1);
                continue;
            }
            if ($ch === '[') {
                $bracketDepth++;
                continue;
            }
            if ($ch === ']') {
                $bracketDepth = max(0, $bracketDepth - 1);
                continue;
            }
            if ($ch === '{') {
                $braceDepth++;
                continue;
            }
            if ($ch === '}') {
                $braceDepth = max(0, $braceDepth - 1);
                continue;
            }

            if ($ch === ';' && $parenDepth === 0 && $bracketDepth === 0 && $braceDepth === 0) {
                return $idx;
            }
        }
    }

    return $start;
}

function collect_operations(array $lines): array
{
    $operations = [];
    $currentWorker = null;

    for ($idx = 0, $count = count($lines); $idx < $count; $idx++) {
        $line = $lines[$idx];

        if (preg_match('/^\s*case\s+(\d+)\s*:\s*$/', $line, $matches) === 1) {
            $currentWorker = (int) $matches[1];
            continue;
        }
        if (preg_match('/^\s*default\s*:\s*$/', $line) === 1) {
            $currentWorker = null;
            continue;
        }

        if ($currentWorker === null) {
            continue;
        }

        if (preg_match('/^\s*Table::/', $line) !== 1) {
            continue;
        }

        $end = find_statement_end($lines, $idx);
        $operations[] = [
            'worker' => $currentWorker,
            'start' => $idx,
            'end' => $end,
        ];
        $idx = $end;
    }

    return $operations;
}

function build_script(array $lines, array $operations, array $activeOperationSet): string
{
    $mutatedLines = $lines;

    foreach ($operations as $operationId => $operation) {
        if (isset($activeOperationSet[$operationId])) {
            continue;
        }

        for ($lineIdx = $operation['start']; $lineIdx <= $operation['end']; $lineIdx++) {
            $mutatedLines[$lineIdx] = comment_out_line($mutatedLines[$lineIdx]);
        }
    }

    return implode('', $mutatedLines);
}

function write_temp_script(string $dir, string $contents): string
{
    $tmp = tempnam($dir, 'final-reduce-script-');
    if ($tmp === false) {
        throw new RuntimeException('Failed to create temp file');
    }

    $tmpPhp = $tmp . '.php';
    if (!@rename($tmp, $tmpPhp)) {
        @unlink($tmp);
        throw new RuntimeException('Failed to create temp file');
    }

    if (file_put_contents($tmpPhp, $contents) === false) {
        @unlink($tmpPhp);
        throw new RuntimeException('Failed to write temp script');
    }

    return $tmpPhp;
}

function build_valgrind_command(string $valgrindBin, string $logPath, array $command): array
{
    return [
        'env',
        'USE_ZEND_ALLOC=0',
        $valgrindBin,
        '--tool=memcheck',
        '--leak-check=no',
        '--errors-for-leak-kinds=none',
        '--log-file=' . $logPath,
        ...$command,
    ];
}

function run_php_once(
    string $phpBin,
    ?string $phpIni,
    array $phpArgs,
    string $scriptPath,
    string $cwd,
    ?int $timeoutSeconds,
    ?string $timeoutBin,
    ?string $valgrindBin
): array {
    $args = [$phpBin, ...$phpArgs];
    if ($phpIni !== null && $phpIni !== '') {
        $args[] = '-c';
        $args[] = $phpIni;
    }
    $args[] = $scriptPath;

    $valgrindLogPath = null;
    $exec = $args;
    if ($valgrindBin !== null) {
        $valgrindLogPath = create_temp_log('final-reduce-script-vg-');
        if ($valgrindLogPath === null) {
            throw new RuntimeException('Failed to create valgrind log file');
        }
        $exec = build_valgrind_command($valgrindBin, $valgrindLogPath, $exec);
    }
    if ($timeoutSeconds !== null && $timeoutBin !== null) {
        $exec = [$timeoutBin, (string) $timeoutSeconds, ...$exec];
    }

    $command = implode(' ', array_map('escapeshellarg', $exec));

    $descriptors = [
        0 => ['pipe', 'r'],
        1 => ['pipe', 'w'],
        2 => ['pipe', 'w'],
    ];

    $pipes = [];
    $proc = proc_open($exec, $descriptors, $pipes, $cwd);
    if (!is_resource($proc)) {
        throw new RuntimeException('Failed to execute PHP binary');
    }

    fclose($pipes[0]);
    $stdout = stream_get_contents($pipes[1]);
    fclose($pipes[1]);
    $stderr = stream_get_contents($pipes[2]);
    fclose($pipes[2]);

    $status = proc_get_status($proc);
    $exitCode = proc_close($proc);

    $finalExit = null;
    $signal = null;
    if (is_array($status)) {
        if (!empty($status['signaled'])) {
            $signal = $status['termsig'] ?? null;
            if (is_int($signal)) {
                $finalExit = 128 + $signal;
            }
        } elseif (isset($status['exitcode']) && is_int($status['exitcode']) && $status['exitcode'] !== -1) {
            $finalExit = $status['exitcode'];
        }
    }

    if ($finalExit === null && is_int($exitCode) && $exitCode !== -1) {
        $finalExit = $exitCode;
    }
    if ($finalExit === null) {
        $finalExit = 1;
    }

    $timedOut = $timeoutSeconds !== null && $finalExit === 124;
    $valgrindErrors = parse_valgrind_error_count($valgrindLogPath);
    if ($valgrindLogPath !== null) {
        @unlink($valgrindLogPath);
    }

    return [
        'command' => $command,
        'cwd' => $cwd,
        'exit_code' => $finalExit,
        'signal' => $signal,
        'timed_out' => $timedOut,
        'valgrind_errors' => $valgrindErrors,
        'stdout' => $stdout,
        'stderr' => $stderr,
    ];
}

function is_crash(int $exitCode): bool
{
    return $exitCode >= 128;
}

function classify_crash(array $run, bool $usesValgrind): bool
{
    if ($usesValgrind) {
        $errors = $run['valgrind_errors'] ?? null;
        return is_int($errors) && $errors > 0;
    }

    return is_crash((int) $run['exit_code']) || !empty($run['timed_out']);
}

function run_php_with_retries(
    string $phpBin,
    ?string $phpIni,
    array $phpArgs,
    string $scriptPath,
    string $cwd,
    int $maxRuns,
    ?int $timeoutSeconds,
    ?string $timeoutBin,
    ?string $valgrindBin
): array {
    $lastRun = null;
    $usesValgrind = $valgrindBin !== null;

    for ($attempt = 1; $attempt <= $maxRuns; $attempt++) {
        $run = run_php_once(
            $phpBin,
            $phpIni,
            $phpArgs,
            $scriptPath,
            $cwd,
            $timeoutSeconds,
            $timeoutBin,
            $valgrindBin
        );
        $lastRun = $run;
        if (classify_crash($run, $usesValgrind)) {
            return [
                'is_crash' => true,
                'attempts' => $attempt,
                'last_run' => $run,
            ];
        }
    }

    return [
        'is_crash' => false,
        'attempts' => $maxRuns,
        'last_run' => $lastRun,
    ];
}

function ddmin(array $ops, callable $test): array
{
    $n = 2;
    $count = count($ops);

    while ($count >= 2) {
        $subsetSize = (int) ceil($count / $n);
        $reduced = false;

        for ($i = 0; $i < $n; $i++) {
            $start = $i * $subsetSize;
            if ($start >= $count) {
                break;
            }

            $subset = array_slice($ops, $start, $subsetSize);
            if ($subset !== [] && $test($subset)) {
                $ops = $subset;
                $count = count($ops);
                $n = 2;
                $reduced = true;
                break;
            }

            $complement = array_values(array_diff($ops, $subset));
            if ($complement !== [] && $test($complement)) {
                $ops = $complement;
                $count = count($ops);
                $n = max($n - 1, 2);
                $reduced = true;
                break;
            }
        }

        if ($reduced) {
            continue;
        }

        if ($n >= $count) {
            break;
        }
        $n = min($n * 2, $count);
    }

    return $ops;
}

$config = parse_args($argv);

$scriptPath = realpath($config['script_path']);
if ($scriptPath === false || !is_file($scriptPath)) {
    fail("Script not found: {$config['script_path']}");
}

$phpBin = resolve_executable_path($config['php_bin']);
if (!is_file($phpBin) || !is_executable($phpBin)) {
    fail("PHP binary not found: {$phpBin}");
}

$phpIni = $config['php_ini'];
if ($phpIni !== null && $phpIni !== '') {
    $resolvedIni = realpath($phpIni);
    if ($resolvedIni === false || !is_file($resolvedIni)) {
        fail("PHP ini not found: {$phpIni}");
    }
    $phpIni = $resolvedIni;
}

$timeoutBin = null;
if (is_int($config['timeout_seconds'])) {
    $timeoutBin = resolve_executable_path('timeout');
    if (!is_file($timeoutBin) || !is_executable($timeoutBin)) {
        fail('timeout binary not found or not executable: timeout');
    }
}

$valgrindBin = null;
if (is_string($config['valgrind_bin'])) {
    $valgrindBin = resolve_executable_path($config['valgrind_bin']);
    if (!is_file($valgrindBin) || !is_executable($valgrindBin)) {
        fail("valgrind binary not found or not executable: {$config['valgrind_bin']}");
    }
}

$lines = file($scriptPath);
if ($lines === false) {
    fail("Failed to read script: {$scriptPath}");
}

$operations = collect_operations($lines);
if ($operations === []) {
    fail('No worker Table:: operations found in script.');
}

$workerCounts = [];
foreach ($operations as $operation) {
    $worker = $operation['worker'];
    $workerCounts[$worker] = ($workerCounts[$worker] ?? 0) + 1;
}
ksort($workerCounts);

$scriptDir = dirname($scriptPath);
$activeOperations = array_keys($operations);
$originalCount = count($activeOperations);

fwrite(STDOUT, "Final reduce (script mode) starting\n");
fwrite(STDOUT, "Script: {$scriptPath}\n");
fwrite(STDOUT, "PHP bin: {$phpBin}\n");
if ($phpIni !== null && $phpIni !== '') {
    fwrite(STDOUT, "PHP ini: {$phpIni}\n");
}
if (is_int($config['timeout_seconds']) && is_string($timeoutBin)) {
    fwrite(STDOUT, "Timeout: {$config['timeout_seconds']}s ({$timeoutBin})\n");
}
if ($valgrindBin !== null) {
    fwrite(STDOUT, "Valgrind: {$valgrindBin} (USE_ZEND_ALLOC=0)\n");
}
if ($config['php_args'] !== []) {
    fwrite(
        STDOUT,
        'Forwarded PHP args: ' . implode(' ', array_map('escapeshellarg', $config['php_args'])) . "\n"
    );
}
fwrite(STDOUT, "Max runs per test: {$config['max_runs']}\n");
fwrite(STDOUT, "Worker operations: {$originalCount}\n");

$workerSummaryParts = [];
foreach ($workerCounts as $worker => $count) {
    $workerSummaryParts[] = sprintf('worker %d=%d', $worker, $count);
}
fwrite(STDOUT, 'Workers: ' . implode(', ', $workerSummaryParts) . "\n");

$testCount = 0;
$test = function (array $candidateOperationIds) use (
    &$testCount,
    $lines,
    $operations,
    $phpBin,
    $phpIni,
    $config,
    $scriptDir,
    $timeoutBin,
    $valgrindBin
): bool {
    $testCount++;

    $activeOperationSet = array_fill_keys($candidateOperationIds, true);
    $contents = build_script($lines, $operations, $activeOperationSet);
    $tmpScript = write_temp_script($scriptDir, $contents);

    $runResult = run_php_with_retries(
        $phpBin,
        $phpIni,
        $config['php_args'],
        $tmpScript,
        $scriptDir,
        $config['max_runs'],
        $config['timeout_seconds'],
        $timeoutBin,
        $valgrindBin
    );

    @unlink($tmpScript);

    $run = $runResult['last_run'];
    if (!is_array($run)) {
        throw new RuntimeException('Failed to execute reducer test run');
    }

    $crash = (bool) $runResult['is_crash'];
    $result = $crash ? 'crash' : 'no crash';
    $details = [];
    if (!empty($run['timed_out'])) {
        $details[] = 'timeout';
    }
    $valgrindErrors = $run['valgrind_errors'] ?? null;
    if (is_int($valgrindErrors)) {
        $details[] = "valgrind_errors={$valgrindErrors}";
    }
    $detailSuffix = $details !== [] ? ' [' . implode(', ', $details) . ']' : '';

    fwrite(
        STDOUT,
        sprintf(
            "test #%d: ops=%d => %s after %d/%d runs (exit %d%s)%s\n",
            $testCount,
            count($candidateOperationIds),
            $result,
            $runResult['attempts'],
            $config['max_runs'],
            $run['exit_code'],
            $run['signal'] !== null ? sprintf(', signal %d', $run['signal']) : '',
            $detailSuffix
        )
    );

    if ($testCount === 1) {
        fwrite(STDOUT, "Command: {$run['command']}\n");
        fwrite(STDOUT, "Cwd: {$run['cwd']}\n");
    }

    return $crash;
};

if (!$test($activeOperations)) {
    if ($valgrindBin !== null) {
        fail('Baseline did not report valgrind memory errors within max runs; cannot reduce.');
    }
    fail('Baseline did not crash or time out within max runs; cannot reduce.');
}

$reducedOperations = ddmin($activeOperations, $test);
$finalCount = count($reducedOperations);

if ($finalCount >= $originalCount) {
    fwrite(STDOUT, "No reduction possible (still {$originalCount} operations).\n");
    exit(0);
}

$finalSet = array_fill_keys($reducedOperations, true);
$finalContents = build_script($lines, $operations, $finalSet);

$outputPath = preg_replace('/\.php$/', '', $scriptPath) . '.final-reduced-script.php';
if ($outputPath === null) {
    $outputPath = $scriptPath . '.final-reduced-script.php';
}

if (file_put_contents($outputPath, $finalContents) === false) {
    fail("Failed to write reduced script: {$outputPath}");
}

fwrite(STDOUT, sprintf("Reduced %d operations to %d operations.\n", $originalCount, $finalCount));
fwrite(STDOUT, "Reduced script: {$outputPath}\n");
